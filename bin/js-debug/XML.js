/**
 * Generated by Apache Royale Compiler from XML.as
 * XML
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('XML');
/* Royale Dependency List: Namespace,QName,XMLList,org.apache.royale.debugging.assertType,org.apache.royale.utils.Language,XML*/




/**
 * @constructor
 * @param {*=} xml
 */
XML = function(xml) {
  var self = this;
  xml = typeof xml !== 'undefined' ? xml : null;
  var /** @type {Function} */ __localFn0__ = function() {
    return this;
  }
  var /** @type {Function} */ __localFn1__ = function(newValue) {
  }
  if (xml) {
    var /** @type {string} */ xmlStr = "" + xml;
    if (xmlStr.indexOf("<") == -1) {
      this._nodeKind = "text";
      this._value = xmlStr;
    } else {
      this.parseXMLStr(xmlStr);
    }
  }
  Object.defineProperty(this, "0", {"get":__localFn0__, "set":__localFn1__, enumerable:true, configurable:true});
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('XML', XML);


/**
 * @private
 * @type {Object}
 */
XML._nameMap = {};


/**
 * @private
 * @param {string} localName
 * @param {string} prefix
 * @param {string} uri
 * @param {boolean} isAttribute
 * @return {QName}
 */
XML.getQName = function(localName, prefix, uri, isAttribute) {
  localName = localName || "";
  prefix = prefix || "";
  uri = uri || "";
  var /** @type {string} */ key = localName + ":" + prefix + ":" + uri + ":" + isAttribute;
  var /** @type {QName} */ qname = XML._nameMap[key];
  if (!qname) {
    qname = new QName();
    if (prefix)
      qname.prefix = prefix;
    if (uri)
      qname.uri = uri;
    if (localName)
      qname.localName = localName;
    qname.isAttribute = isAttribute;
    XML._nameMap[key] = qname;
  }
  return qname;
};


/**
 * Method to free up references to shared QName objects.
 * Probably only worth doing if most or all XML instances can be garbage-collected.
 * @langversion 3.0
 * @productversion Royale 0.9
 * @export
 */
XML.clearQNameCache = function() {
  XML._nameMap = {};
};


/**
 * @private
 * @type {Namespace}
 */
XML.defaultNamespace;


/**
 * @export
 * @param {*} ns
 */
XML.setDefaultNamespace = function(ns) {
  if (!ns)
    XML.defaultNamespace = null;
  else
    XML.defaultNamespace = new Namespace(ns);
};


/**
 * @export
 * @type {boolean}
 */
XML.ignoreComments = true;


/**
 * @export
 * @type {boolean}
 */
XML.ignoreProcessingInstructions = true;


/**
 * @export
 * @type {boolean}
 */
XML.ignoreWhitespace = true;


/**
 * @private
 * @type {number}
 */
XML._prettyIndent = 2;


/**
 * @private
 * @type {string}
 */
XML._indentStr = "  ";


/**
 * @private
 * @type {string}
 */
XML.INDENT_CHAR = " ";


/**
 * @export
 * @type {boolean}
 */
XML.prettyPrinting = true;


/**
 * @private
 * @param {string} value
 * @return {string}
 */
XML.escapeAttributeValue = function(value) {
  var /** @type {Array} */ outArr = [];
  var /** @type {Array} */ arr = String(value).split("");
  var /** @type {number} */ len = arr.length;
  for (var /** @type {number} */ i = 0; i < len; i++) {
    switch (arr[i]) {
      case "<":
        outArr[i] = "&lt;";
        break;
      case "&":
        outArr[i] = "&amp;";
        break;
      case "\n":
        outArr[i] = "&#xA;";
        break;
      case "\r":
        outArr[i] = "&#xD;";
        break;
      case "\t":
        outArr[i] = "&#x9;";
        break;
      default:
        outArr[i] = arr[i];
        break;
    }
  }
  return outArr.join("");
};


/**
 * @private
 * @param {string} value
 * @return {string}
 */
XML.escapeElementValue = function(value) {
  var /** @type {number} */ i = 0;
  var /** @type {Array} */ outArr = [];
  var /** @type {Array} */ arr = value.split("");
  for (i = 0; i < arr.length; i++) {
    switch (arr[i]) {
      case "<":
        outArr[i] = "&lt;";
        break;
      case ">":
        outArr[i] = "&gt;";
        break;
      case "&":
        outArr[i] = "&amp;";
        break;
      default:
        outArr[i] = arr[i];
        break;
    }
  }
  return outArr.join("");
};


/**
 * @private
 * @param {Attr} att
 * @param {XML} parent
 * @return {XML}
 */
XML.insertAttribute = function(att, parent) {
  var /** @type {XML} */ xml = new XML();
  xml.setParent(parent);
  xml.setNodeKind("attribute");
  xml.setName(att.name);
  xml.setValue(att.value);
  parent.addChildInternal(xml);
  return xml;
};


/**
 * @private
 * @param {Element} node
 * @param {XML} xml
 */
XML.iterateElement = function(node, xml) {
  var /** @type {number} */ i = 0;
  var /** @type {*} */ attrs = node.attributes;
  var /** @type {number} */ len = node.attributes.length;
  for (i = 0; i < len; i++) {
    XML.insertAttribute(attrs[i], xml);
  }
  var /** @type {NodeList} */ childNodes = node.childNodes;
  len = childNodes.length;
  for (i = 0; i < len; i++) {
    var /** @type {XML} */ child = XML.fromNode(childNodes[i]);
    xml.addChildInternal(child);
  }
};


/**
 * returns an XML object from an existing node without the need to parse the XML.
 * The new XML object is not normalized
 * @private
 * @param {Element} node
 * @return {XML}
 */
XML.fromNode = function(node) {
  var /** @type {XML} */ xml;
  var /** @type {number} */ i = 0;
  var /** @type {*} */ data = node.nodeValue;
  var /** @type {string} */ localName = node.nodeName;
  var /** @type {string} */ prefix = node.prefix;
  if (prefix && localName.indexOf(prefix + ":") == 0) {
    localName = localName.substr(prefix.length + 1);
  }
  var /** @type {QName} */ qname = XML.getQName(localName, prefix, node.namespaceURI, false);
  switch (node.nodeType) {
    case 1:
      xml = new XML();
      xml.setNodeKind("element");
      xml.setName(qname);
      XML.iterateElement(node, xml);
      break;
    case 3:
      xml = new XML();
      xml.setNodeKind("text");
      xml.setName(qname);
      if (XML.ignoreWhitespace)
        data = data.trim();
      xml.setValue(data);
      break;
    case 4:
      xml = new XML();
      xml.setName(qname);
      xml.setNodeKind("text");
      data = "<![CDATA[" + data + "]]>";
      xml.setValue(data);
      break;
    case 7:
      xml = new XML();
      xml.setNodeKind("processing-instruction");
      xml.setName(qname);
      xml.setValue(data);
      break;
    case 8:
      xml = new XML();
      xml.setNodeKind("comment");
      xml.setValue(data);
      break;
    default:
      throw new TypeError("Unknown XML node type!");
      break;
  }
  return xml;
};


/**
 * @private
 * @param {Namespace} ns
 * @param {Array} arr
 * @param {boolean=} considerPrefix
 * @return {boolean}
 */
XML.namespaceInArray = function(ns, arr, considerPrefix) {
  considerPrefix = typeof considerPrefix !== 'undefined' ? considerPrefix : true;
  if (!arr)
    return false;
  var /** @type {number} */ i = 0;
  for (i = 0; i < arr.length; i++) {
    if (ns.uri == arr[i].uri) {
      if (!considerPrefix)
        return true;
      if (ns.prefix == arr[i].prefix)
        return true;
    }
  }
  return false;
};


/**
 * @private
 * @param {string} value
 * @return {string}
 */
XML.trimXMLWhitespace = function(value) {
  return value.replace(/^\s+|\s+$/gm, '');
};


/**
 * [static] Returns an object with the following properties set to the default values: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, and prettyPrinting.
 * @asreturn 
 * 
 * @export
 * @return {Object}
 */
XML.defaultSettings = function() {
  return {ignoreComments:true, ignoreProcessingInstructions:true, ignoreWhitespace:true, prettyIndent:2, prettyPrinting:true};
};


/**
 * [static] Sets values for the following XML properties: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, and prettyPrinting.
 * @asparam rest
 * 
 * @export
 * @param {Object} value
 */
XML.setSettings = function(value) {
  if (!value)
    return;
  XML.ignoreComments = value.ignoreComments === undefined ? XML.ignoreComments : value.ignoreComments;
  XML.ignoreProcessingInstructions = value.ignoreProcessingInstructions === undefined ? XML.ignoreProcessingInstructions : value.ignoreProcessingInstructions;
  XML.ignoreWhitespace = value.ignoreWhitespace === undefined ? XML.ignoreWhitespace : value.ignoreWhitespace;
  XML["prettyIndent"] = value.prettyIndent === undefined ? XML["prettyIndent"] : value.prettyIndent;
  XML.prettyPrinting = value.prettyPrinting === undefined ? XML.prettyPrinting : value.prettyPrinting;
};


/**
 * [static] Retrieves the following properties: ignoreComments, ignoreProcessingInstructions, ignoreWhitespace, prettyIndent, and prettyPrinting.
 * 
 * @asreturn 
 * 
 * @export
 * @return {Object}
 */
XML.settings = function() {
  return {ignoreComments:XML.ignoreComments, ignoreProcessingInstructions:XML.ignoreProcessingInstructions, ignoreWhitespace:XML.ignoreWhitespace, prettyIndent:XML["prettyIndent"], prettyPrinting:XML.prettyPrinting};
};


/**
 * @private
 * @type {string}
 */
XML.errorNS;


/**
 * @private
 * @param {string} xml
 */
XML.prototype.parseXMLStr = function(xml) {
  xml = xml.replace(/&(?![\w]+;)/g, "&amp;");
  var /** @type {DOMParser} */ parser = new DOMParser();
  if (XML.errorNS == null) {
    try {
      XML.errorNS = parser.parseFromString('<', 'application/xml').getElementsByTagName("parsererror")[0].namespaceURI;
    } catch (err) {
      XML.errorNS = "na";
    }
  }
  try {
    var /** @type {Document} */ doc = parser.parseFromString(xml, "application/xml");
  } catch (err) {
    throw err;
  }
  var /** @type {NodeList} */ errorNodes = doc.getElementsByTagNameNS(XML.errorNS, 'parsererror');
  if (errorNodes.length > 0)
    throw new Error(errorNodes[0].innerHTML);
  for (var /** @type {number} */ i = 0; i < doc.childNodes.length; i++) {
    var /** @type {Element} */ node = doc.childNodes[i];
    if (node.nodeType == 1) {
      this._version = doc.xmlVersion;
      this._encoding = doc.xmlEncoding;
      this._name = XML.getQName(node.localName, node.prefix, node.namespaceURI, false);
      XML.iterateElement(node, this);
    } else {
    }
  }
  this.normalize();
};


/**
 * @private
 * @type {Array}
 */
XML.prototype._children;


/**
 * @private
 * @type {Array}
 */
XML.prototype._attributes;


/**
 * @private
 * @type {Array}
 */
XML.prototype._processingInstructions;


/**
 * @private
 * @type {XML}
 */
XML.prototype._parent;


/**
 * @private
 * @type {string}
 */
XML.prototype._value;


/**
 * @private
 * @type {string}
 */
XML.prototype._version;


/**
 * @private
 * @type {string}
 */
XML.prototype._encoding;


/**
 * @private
 * @type {Namespace}
 */
XML.prototype._appliedNamespace;


/**
 * @private
 * @type {Array}
 */
XML.prototype._namespaces;


/**
 * @private
 * @return {Array}
 */
XML.prototype.getNamespaces = function() {
  if (!this._namespaces)
    this._namespaces = [];
  return this._namespaces;
};


/**
 * @private
 * @type {string}
 */
XML.prototype._origStr;


/**
 * @asprivate
 * 
 * Similar to appendChild, but accepts all XML types (text, comment, processing-instruction, attribute, or element)
 *
 * 	
 * @export
 * @param {XML} child
 */
XML.prototype.addChild = function(child) {
  if (!child)
    return;
  this.addChildInternal(child);
  this.normalize();
};


/**
 * @private
 * @param {XML} child
 */
XML.prototype.addChildInternal = function(child) {
  org.apache.royale.debugging.assertType(child, XML, "Type must be XML");
  child.setParent(this);
  if (child.nodeKind() == "attribute")
    this.getAttributes().push(child);
  else
    this.getChildren().push(child);
};


/**
 * @private
 * @return {Array}
 */
XML.prototype.getChildren = function() {
  if (!this._children)
    this._children = [];
  return this._children;
};


/**
 * @private
 * @return {Array}
 */
XML.prototype.getAttributes = function() {
  if (!this._attributes)
    this._attributes = [];
  return this._attributes;
};


/**
 * Adds a namespace to the set of in-scope namespaces for the XML object.
 *
 * @asparam ns
 * @asreturn 
 * 	
 * @export
 * @param {Namespace} ns
 * @return {XML}
 */
XML.prototype.addNamespace = function(ns) {
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return this;
  if (ns.prefix === null)
    return this;
  if (ns.prefix == "" && this.name().uri == "")
    return this;
  var /** @type {Namespace} */ match = null;
  var /** @type {number} */ i = 0;
  var /** @type {Array} */ nspaces = this.getNamespaces();
  for (i = 0; i < nspaces.length; i++) {
    if (nspaces[i].prefix == ns.prefix) {
      match = nspaces[i];
      break;
    }
  }
  if (match)
    nspaces[i] = ns;
  else
    nspaces.push(ns);
  if (ns.prefix == this.name().prefix)
    this.name().prefix = null;
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (this._attributes[i].name().prefix == ns.prefix)
      this._attributes[i].name().prefix = null;
  }
  return this;
};


/**
 * Appends the given child to the end of the XML object's properties.
 *
 * @asparam child
 * @asreturn 
 * 
 * @export
 * @param {*} child
 * @return {XML}
 */
XML.prototype.appendChild = function(child) {
  var /** @type {string} */ childType = typeof(child);
  if (childType != "object")
    child = this.xmlFromStringable(child);
  this.appendChildInternal(child);
  this.normalize();
  return this;
};


/**
 * @private
 * @param {*} child
 */
XML.prototype.appendChildInternal = function(child) {
  if (org.apache.royale.utils.Language.is(child, XMLList)) {
    var /** @type {number} */ len = Number(child.length());
    for (var /** @type {number} */ i = 0; i < len; i++) {
      this.appendChildInternal(child[0]);
    }
  } else {
    org.apache.royale.debugging.assertType(child, XML, "Type must be XML");
    child.setParent(this);
    this.getChildren().push(child);
  }
};


/**
 * Returns the XML value of the attribute that has the name matching the attributeName parameter.
 *
 * @asparam attributeName
 * @asreturn 
 * 
 * @export
 * @param {*} attributeName
 * @return {XMLList}
 */
XML.prototype.attribute = function(attributeName) {
  var /** @type {number} */ i = 0;
  if (attributeName == "*")
    return this.attributes();
  attributeName = this.toAttributeName(attributeName);
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (this._attributes[i].name().matches(attributeName))
      list.append(this._attributes[i]);
  }
  list.targetObject = this;
  list.targetProperty = attributeName;
  return list;
};


/**
 * Returns a list of attribute values for the given XML object.
 *
 * @asreturn 
 * 
 * @export
 * @return {XMLList}
 */
XML.prototype.attributes = function() {
  var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++)
    list.append(this._attributes[i]);
  list.targetObject = this;
  return list;
};


/**
 * Lists the children of an XML object.
 *
 * @asparam propertyName
 * @asreturn 
 * 
 * @export
 * @param {Object} propertyName
 * @return {XMLList}
 */
XML.prototype.child = function(propertyName) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  var /** @type {XMLList} */ list = new XMLList();
  if (parseInt(propertyName, 10).toString() == propertyName) {
    if (propertyName != "0")
      return null;
    list.append(this);
    list.targetObject = this;
    return list;
  }
  propertyName = this.toXMLName(propertyName);
  if (propertyName.isAttribute) {
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (propertyName.matches(this._attributes[i].name()))
        list.append(this._attributes[i]);
    }
  } else {
    len = this.childrenLength();
    for (i = 0; i < len; i++) {
      if (propertyName.matches(this._children[i].name()))
        list.append(this._children[i]);
    }
  }
  list.targetObject = this;
  list.targetProperty = propertyName;
  return list;
};


/**
 * Identifies the zero-indexed position of this XML object within the context of its parent.
 *
 * @asreturn 
 * 
 * @export
 * @return {number}
 */
XML.prototype.childIndex = function() {
  if (!this._parent)
    return -1;
  return this._parent.getIndexOf(this);
};


/**
 * Lists the children of the XML object in the sequence in which they appear.
 *
 * @asreturn 
 * 
 * @export
 * @return {XMLList}
 */
XML.prototype.children = function() {
  var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++)
    list.append(this._children[i]);
  list.targetObject = this;
  return list;
};


/**
 * Lists the properties of the XML object that contain XML comments.
 *
 * @asreturn 
 * 
 * @export
 * @return {XMLList}
 */
XML.prototype.comments = function() {
  var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "comment")
      list.append(this._children[i]);
  }
  list.targetObject = this;
  return list;
};


/**
 * @export
 * @param {*} list
 * @return {XMLList}
 */
XML.prototype.concat = function(list) {
  if (org.apache.royale.utils.Language.is(list, XML)) {
    var /** @type {XMLList} */ newList = new XMLList();
    newList.append(list);
    list = newList;
  }
  if (!org.apache.royale.utils.Language.is(list, XMLList))
    throw new TypeError("invalid type");
  var /** @type {XMLList} */ retVal = new XMLList();
  retVal.append(this);
  var /** @type {XML} */ item;
  var foreachiter0_target = list;
  for (var foreachiter0 in foreachiter0_target) 
  {
  item = foreachiter0_target[foreachiter0];
  
    retVal.append(item);}
  
  return retVal;
};


/**
 * Compares the XML object against the given value parameter.
 *
 * @asparam value
 * @asreturn 
 * 
 * @export
 * @param {*} value
 * @return {boolean}
 */
XML.prototype.contains = function(value) {
  if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList))
    return this.equals(value);
  return value == this;
};


/**
 * Returns a copy of the given XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @return {XML}
 */
XML.prototype.copy = function() {
  var /** @type {number} */ i = 0;
  var /** @type {XML} */ xml = new XML();
  xml.setNodeKind(this._nodeKind);
  xml.setName(this.name());
  xml.setValue(this._value);
  var /** @type {number} */ len = 0;
  len = this.namespaceLength();
  for (i = 0; i < len; i++) {
    xml.addNamespace(new Namespace(this._namespaces[i]));
  }
  len = this.attributeLength();
  for (i = 0; i < len; i++)
    xml.addChildInternal(this._attributes[i].copy());
  len = this.childrenLength();
  for (i = 0; i < len; i++)
    xml.addChildInternal(this._children[i].copy());
  return xml;
};


/**
 * @private
 * @param {number} idx
 */
XML.prototype.deleteChildAt = function(idx) {
  if (idx < 0)
    return;
  if (idx >= this.childrenLength())
    return;
  var /** @type {XML} */ child = this._children[idx];
  child._parent = null;
  this._children.splice(idx, 1);
};


/**
 * Returns all descendants (children, grandchildren, great-grandchildren, and so on) of the XML object that have the given name parameter.
 * 
 * @asparam name
 * @asreturn 
 * 
 * @export
 * @param {Object=} name
 * @return {XMLList}
 */
XML.prototype.descendants = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  if (!name)
    name = "*";
  name = this.toXMLName(name);
  var /** @type {XMLList} */ list = new XMLList();
  if (name.isAttribute) {
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (name.matches(this._attributes[i].name()))
        list.append(this._attributes[i]);
    }
  }
  len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "element") {
      if (name.matches(this._children[i].name()))
        list.append(this._children[i]);
      list.concat(this._children[i].descendants(name));
    }
  }
  return list;
};


/**
 * Lists the elements of an XML object. (handles E4X dot notation)
 * 
 * @asparam name
 * @asreturn 
 * 
 * @export
 * @param {Object=} name
 * @return {XMLList}
 */
XML.prototype.elements = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  if (!name)
    name = "*";
  name = this.toXMLName(name);
  var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "element" && name.matches(this._children[i].name()))
      list.append(this._children[i]);
  }
  list.targetObject = this;
  list.targetProperty = name;
  return list;
};


/**
 * for each should work on XML too
 * @asprivate
 * @export
 * @return {Array}
 */
XML.prototype.elementNames = function() {
  return [0];
};


/**
 * @export
 * @param {*} xml
 * @return {boolean}
 */
XML.prototype.equals = function(xml) {
  var /** @type {number} */ i = 0;
  if (!org.apache.royale.utils.Language.is(xml, XML))
    return false;
  if (xml.nodeKind() != this._nodeKind)
    return false;
  if (!this.name().equals(xml.name()))
    return false;
  var /** @type {Array} */ selfAttrs = this.getAttributeArray();
  var /** @type {Array} */ xmlAttrs = xml.getAttributeArray();
  if (selfAttrs.length != xmlAttrs.length)
    return false;
  if (this.getValue() != xml.getValue())
    return false;
  for (i = 0; i < selfAttrs.length; i++) {
    if (!xml.hasAttribute(selfAttrs[i]))
      return false;
  }
  var /** @type {Array} */ selfChldrn = this.getChildrenArray();
  var /** @type {Array} */ xmlChildren = xml.getChildrenArray();
  if (selfChldrn.length != xmlChildren.length)
    return false;
  for (i = 0; i < selfChldrn.length; i++) {
    if (!selfChldrn[i].equals(xmlChildren[i]))
      return false;
  }
  return true;
};


/**
 * @export
 * @param {*} nameOrXML
 * @param {string=} value
 * @return {boolean}
 */
XML.prototype.hasAttribute = function(nameOrXML, value) {
  value = typeof value !== 'undefined' ? value : null;
  if (!this._attributes)
    return false;
  var /** @type {QName} */ name;
  if (org.apache.royale.utils.Language.is(nameOrXML, XML)) {
    name = nameOrXML.name();
    value = org.apache.royale.utils.Language.string(nameOrXML.getValue());
  } else {
    name = new QName(nameOrXML);
  }
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (name.matches(this._attributes[i].name())) {
      if (!value)
        return true;
      return value == this._attributes[i].getValue();
    }
  }
  return false;
};


/**
 * @private
 * @param {Array} namespaces
 * @return {Array}
 */
XML.prototype.getAncestorNamespaces = function(namespaces) {
  namespaces = namespaces.slice();
  var /** @type {number} */ nsIdx = 0;
  var /** @type {number} */ pIdx = 0;
  if (this._parent) {
    var /** @type {Array} */ parentNS = this._parent.inScopeNamespaces();
    var /** @type {number} */ len = parentNS.length;
    for (pIdx = 0; pIdx < len; pIdx++) {
      var /** @type {Namespace} */ curNS = parentNS[pIdx];
      var /** @type {boolean} */ doInsert = true;
      for (nsIdx = 0; nsIdx < namespaces.length; nsIdx++) {
        if (curNS.uri == namespaces[nsIdx].uri && curNS.prefix == namespaces[nsIdx].prefix) {
          doInsert = false;
          break;
        }
      }
      if (doInsert)
        namespaces.push(curNS);
    }
    namespaces = this._parent.getAncestorNamespaces(namespaces);
  }
  return namespaces;
};


/**
 * @export
 * @return {Array}
 */
XML.prototype.getAttributeArray = function() {
  return this._attributes ? this._attributes.slice() : [];
};


/**
 * @export
 * @return {Array}
 */
XML.prototype.getChildrenArray = function() {
  return this._children ? this._children.slice() : [];
};


/**
 * @export
 * @param {XML} elem
 * @return {number}
 */
XML.prototype.getIndexOf = function(elem) {
  return this._children ? this._children.indexOf(elem) : -1;
};


/**
 * @private
 * @return {number}
 */
XML.prototype.childrenLength = function() {
  return this._children ? this._children.length : 0;
};


/**
 * @private
 * @return {number}
 */
XML.prototype.attributeLength = function() {
  return this._attributes ? this._attributes.length : 0;
};


/**
 * @private
 * @return {number}
 */
XML.prototype.namespaceLength = function() {
  return this._namespaces ? this._namespaces.length : 0;
};


/**
 * @private
 * @param {string} prefix
 * @return {string}
 */
XML.prototype.getURI = function(prefix) {
  var /** @type {number} */ i = 0;
  if (!this._namespaces)
    return "";
  var /** @type {Array} */ namespaces = this.getAncestorNamespaces(this._namespaces);
  for (i = 0; i < namespaces.length; i++) {
    if (namespaces[i].prefix == prefix)
      return namespaces[i].uri;
  }
  return "";
};


/**
 * @export
 * @return {string}
 */
XML.prototype.getValue = function() {
  return this._value;
};


/**
 * @export
 * @param {*} obj
 * @return {boolean}
 */
XML.prototype.hasAncestor = function(obj) {
  if (!obj)
    return false;
  var /** @type {XML} */ parent = this.parent();
  while (parent) {
    if (obj == parent)
      return true;
    parent = parent.parent();
  }
  return false;
};


/**
 * Checks to see whether the XML object contains complex content.
 * 
 * @asreturn 
 * 
 * @export
 * @return {boolean}
 */
XML.prototype.hasComplexContent = function() {
  if (this._nodeKind == "attribute" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "text")
    return false;
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "element")
      return true;
  }
  return false;
};


/**
 * @export
 * @override
 */
XML.prototype.hasOwnProperty = function(p) {
  if (parseInt(p, 10).toString() == p)
    return p == "0";
  var /** @type {QName} */ name = this.toXMLName(p);
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  if (name.isAttribute) {
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (this._attributes[i].name().matches(name))
        return true;
    }
  } else {
    len = this.childrenLength();
    for (i = 0; i < len; i++) {
      if (this._children[i].nodeKind() != "element")
        continue;
      if (this._children[i].name().matches(name))
        return true;
    }
  }
  return false;
};


/**
 * Checks to see whether the XML object contains simple content.
 * 
 * @asreturn 
 * 
 * @export
 * @return {boolean}
 */
XML.prototype.hasSimpleContent = function() {
  if (this._nodeKind == "comment" || this._nodeKind == "processing-instruction")
    return false;
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "element")
      return false;
  }
  return true;
};


/**
 * Lists the namespaces for the XML object, based on the object's parent.
 * 
 * @asreturn 
 * 
 * @export
 * @return {Array}
 */
XML.prototype.inScopeNamespaces = function() {
  return this._namespaces ? this._namespaces.slice() : [];
};


/**
 * @private
 * @param {XML} child
 * @param {number} idx
 */
XML.prototype.insertChildAt = function(child, idx) {
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return;
  if (!child)
    return;
  var /** @type {XML} */ parent = child.parent();
  if (parent)
    parent.removeChild(child);
  child.setParent(this);
  this.getChildren().splice(idx, 0, child);
};


/**
 * Inserts the given child2 parameter after the child1 parameter in this XML object and returns the resulting object.
 * 
 * @asparam child1
 * @asparam child2
 * @asreturn 
 * 
 * @export
 * @param {XML} child1
 * @param {XML} child2
 * @return {XML}
 */
XML.prototype.insertChildAfter = function(child1, child2) {
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return null;
  if (!child1) {
    this.insertChildAt(child2, 0);
    return child2;
  }
  var /** @type {number} */ idx = this.getIndexOf(child1);
  if (idx >= 0) {
    this.insertChildAt(child2, idx + 1);
  }
  return child2;
};


/**
 * Inserts the given child2 parameter before the child1 parameter in this XML object and returns the resulting object.
 * 
 * @asparam child1
 * @asparam child2
 * @asreturn 
 * 
 * @export
 * @param {XML} child1
 * @param {XML} child2
 * @return {XML}
 */
XML.prototype.insertChildBefore = function(child1, child2) {
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return null;
  if (!child1) {
    var /** @type {number} */ len = this.childrenLength();
    this.insertChildAt(child2, len);
    return child2;
  }
  var /** @type {number} */ idx = this.getIndexOf(child1);
  if (idx >= 0) {
    this.insertChildAt(child2, idx);
  }
  return child2;
};


/**
 * For XML objects, this method always returns the integer 1.
 * 
 * @asreturn 
 * 
 * @export
 * @return {number}
 */
XML.prototype.length = function() {
  return 1;
};


/**
 * Gives the local name portion of the qualified name of the XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @return {Object}
 */
XML.prototype.localName = function() {
  return this.name().localName;
};


/**
 * @private
 * @type {QName}
 */
XML.prototype._name;


/**
 * Gives the qualified name for the XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @return {Object}
 */
XML.prototype.name = function() {
  if (!this._name)
    this._name = XML.getQName("", "", "", false);
  return this._name;
};


/**
 * If no parameter is provided, gives the namespace associated with the qualified name of this XML object.
 * 
 * @asparam prefix
 * @asreturn 
 * 
 * @export
 * @param {string=} prefix
 * @return {*}
 */
XML.prototype.namespace = function(prefix) {
  prefix = typeof prefix !== 'undefined' ? prefix : null;
  var /** @type {number} */ i = 0;
  if (prefix) {
    var /** @type {number} */ len = this.namespaceLength();
    for (i = 0; i < len; i++) {
      if (this._namespaces[i].prefix == prefix)
        return this._namespaces[i];
    }
    if (this._parent)
      return this._parent.namespace(prefix);
    return null;
  }
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction")
    return null;
  return this.name().getNamespace(this.namespaceDeclarations());
};


/**
 * Lists namespace declarations associated with the XML object in the context of its parent.
 * 
 * @asreturn 
 * 
 * @export
 * @return {Array}
 */
XML.prototype.namespaceDeclarations = function() {
  var /** @type {number} */ i = 0;
  var /** @type {Array} */ retVal = [];
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return retVal;
  var /** @type {Array} */ declaredNS = this._namespaces ? this._namespaces.slice() : [];
  var /** @type {XML} */ parent = this._parent;
  while (parent) {
    var /** @type {Array} */ parentNS = parent.inScopeNamespaces();
    var /** @type {number} */ idx = 0;
    var /** @type {number} */ pIdx = 0;
    for (pIdx = 0; i < parentNS.length; pIdx++) {
      var /** @type {string} */ uri = org.apache.royale.utils.Language.string(parentNS[pIdx].uri);
      var /** @type {string} */ prefix = org.apache.royale.utils.Language.string(parentNS[pIdx].prefix);
      for (idx = 0; i < declaredNS.length; idx++) {
        if (declaredNS[idx].uri == uri && declaredNS[idx].prefix == prefix) {
          declaredNS.push(parentNS[pIdx]);
          break;
        }
      }
    }
    parent = parent.parent();
  }
  return declaredNS;
};


/**
 * @private
 * @type {string}
 */
XML.prototype._nodeKind = "element";


/**
 * Specifies the type of node: text, comment, processing-instruction, attribute, or element.
 * @asreturn 
 * 
 * @export
 * @return {string}
 */
XML.prototype.nodeKind = function() {
  return this._nodeKind;
};


/**
 * For the XML object and all descendant XML objects, merges adjacent text nodes and eliminates empty text nodes.
 * 
 * @asreturn 
 * 
 * @export
 * @return {XML}
 */
XML.prototype.normalize = function() {
  var /** @type {number} */ len = this.childrenLength() - 1;
  var /** @type {XML} */ lastChild;
  for (var /** @type {number} */ i = len; i >= 0; i--) {
    var /** @type {XML} */ child = this._children[i];
    if (child.nodeKind() == "element") {
      child.normalize();
    } else if (child.nodeKind() == "text") {
      if (lastChild && lastChild.nodeKind() == "text") {
        child.setValue(child.s() + lastChild.s());
        this.deleteChildAt(i + 1);
      }
      if (!child.s())
        this.deleteChildAt(i);
    }
    lastChild = child;
  }
  return this;
};


/**
 * Returns the parent of the XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @return {*}
 */
XML.prototype.parent = function() {
  return this._parent;
};


/**
 * @export
 * @param {*} rightHand
 * @return {*}
 */
XML.prototype.plus = function(rightHand) {
  var /** @type {XMLList} */ list = new XMLList();
  list.append(this);
  return list.plus(rightHand);
};


/**
 * @private
 * @param {*} value
 * @return {XML}
 */
XML.prototype.xmlFromStringable = function(value) {
  var /** @type {string} */ str = org.apache.royale.utils.Language.string(value.toString());
  var /** @type {XML} */ xml = new XML();
  xml.setNodeKind("text");
  xml.setValue(str);
  return xml;
};


/**
 * Inserts the provided child object into the XML element before any existing XML properties for that element.
 * @asparam value
 * @asreturn 
 * 
 * @export
 * @param {XML} child
 * @return {XML}
 */
XML.prototype.prependChild = function(child) {
  var /** @type {string} */ childType = typeof(child);
  if (childType != "object")
    child = this.xmlFromStringable(child);
  this.prependChildInternal(child);
  this.normalize();
  return this;
};


/**
 * @private
 * @param {*} child
 */
XML.prototype.prependChildInternal = function(child) {
  if (org.apache.royale.utils.Language.is(child, XMLList)) {
    var /** @type {number} */ len = Number(child.length());
    for (var /** @type {number} */ i = 0; i < len; i++) {
      this.prependChildInternal(child[0]);
    }
  } else {
    org.apache.royale.debugging.assertType(child, XML, "Type must be XML");
    child.setParent(this);
    this.getChildren().unshift(child);
  }
};


/**
 * If a name parameter is provided, lists all the children of the XML object that contain processing instructions with that name.
 * 
 * @asparam name
 * @asreturn 
 * 
 * @export
 * @param {string=} name
 * @return {XMLList}
 */
XML.prototype.processingInstructions = function(name) {
  name = typeof name !== 'undefined' ? name : "*";
  var /** @type {number} */ i = 0;
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "processing-instruction")
      list.append(this._children[i]);
  }
  list.targetObject = this;
  return list;
};


/**
 * Removes the given chid for this object and returns the removed child.
 * 
 * @asparam child
 * @asreturn 
 * 
 * @export
 * @param {XML} child
 * @return {boolean}
 */
XML.prototype.removeChild = function(child) {
  var /** @type {number} */ i = 0;
  var /** @type {XML} */ removed;
  if (!child)
    return false;
  if (!org.apache.royale.utils.Language.is(child, XML))
    return this.removeChildByName(child);
  if (child.nodeKind() == "attribute") {
    var /** @type {number} */ len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (child.equals(this._attributes[i])) {
        removed = this._attributes[i];
        removed._parent = null;
        this._attributes.splice(i, 1);
        return true;
      }
    }
    return false;
  }
  var /** @type {number} */ idx = this.getIndexOf(child);
  if (idx < 0)
    return false;
  removed = this._children.splice(idx, 1);
  child._parent = null;
  return true;
};


/**
 * @private
 * @param {*} name
 * @return {boolean}
 */
XML.prototype.removeChildByName = function(name) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  name = this.toXMLName(name);
  var /** @type {XML} */ child = null;
  var /** @type {boolean} */ removedItem = false;
  if (name.isAttribute) {
    len = this.attributeLength() - 1;
    for (i = len; i >= 0; i--) {
      if (this._attributes[i].name().matches(name)) {
        child = this._attributes[i];
        child._parent = null;
        this._attributes.splice(i, 1);
        removedItem = true;
      }
    }
    return removedItem;
  }
  len = this.childrenLength() - 1;
  for (i = len; i >= 0; i--) {
    if (this._children[i].name().matches(name)) {
      child = this._children[i];
      child._parent = null;
      this._children.splice(i, 1);
      removedItem = true;
    }
  }
  return removedItem;
};


/**
 * @export
 * @param {number} index
 */
XML.prototype.removeChildAt = function(index) {
  throw new Error("Cannot call delete on XML");
};


/**
 * Removes the given namespace for this object and all descendants.
 * 
 * @asparam ns
 * @asreturn 
 * 
 * @export
 * @param {*} ns
 * @return {XML}
 */
XML.prototype.removeNamespace = function(ns) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return this;
  if (!org.apache.royale.utils.Language.is(ns, Namespace))
    ns = new Namespace(ns);
  if (ns == this.name().getNamespace(this._namespaces))
    return this;
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    if (ns == this._attributes[i].name().getNamespace(this._namespaces))
      return this;
  }
  len = this.namespaceLength();
  for (i = len - 1; i >= 0; i--) {
    if (this._namespaces[i].uri == ns.uri && this._namespaces[i].prefix == ns.prefix)
      this._namespaces.splice(i, 1);
    else if (ns.prefix == null && this._namespaces[i].uri == ns.uri)
      this._namespaces.splice(i, 1);
  }
  len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "element")
      this._children[i].removeNamespace(ns);
  }
  return this;
};


/**
 * Replaces the properties specified by the propertyName parameter with the given value parameter.
 * 
 * @asparam propertyName
 * @asparam value
 * @asreturn 
 * 
 * @export
 * @param {Object} propertyName
 * @param {*} value
 * @return {*}
 */
XML.prototype.replace = function(propertyName, value) {
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute") {
    return this.s().replace(propertyName, value);
  }
  if (value === null || value === undefined)
    return this;
  if (org.apache.royale.utils.Language.is(value, XML) || org.apache.royale.utils.Language.is(value, XMLList))
    value = value.copy();
  else
    value = value.toString();
  return null;
};


/**
 * @export
 * @param {number} idx
 * @param {*} v
 */
XML.prototype.replaceChildAt = function(idx, v) {
  var /** @type {number} */ len = 0;
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction" || this._nodeKind == "attribute")
    return;
  len = this.childrenLength();
  if (idx > len)
    idx = len;
  this.getChildren();
  if (org.apache.royale.utils.Language.is(v, XML) && v.nodeKind() != "attribute") {
    if (v.nodeKind() == "element" && (v == this || this.isAncestor(v)))
      throw new TypeError("cannot assign parent xml as child");
    v.setParent(this);
    if (this._children[idx])
      this.removeChild(this._children[idx]);
    this.insertChildAt(v, idx);
  } else if (org.apache.royale.utils.Language.is(v, XMLList)) {
    if (this._children[idx])
      this._children[idx]._parent = null;
    len = Number(v.length());
    v[0].setParent(this);
    this._children[idx] = v[0];
    var /** @type {number} */ listIdx = 1;
    var /** @type {XML} */ chld = v[0];
    while (listIdx < len) {
      chld = v[listIdx];
      this.insertChildAt(chld, idx + listIdx);
      listIdx++;
    }
  } else {
  }
};


/**
 * @private
 * @param {XML} xml
 * @return {boolean}
 */
XML.prototype.isAncestor = function(xml) {
  var /** @type {XML} */ p = this.parent();
  while (p) {
    if (p == xml)
      return true;
    p = p.parent();
  }
  return false;
};


/**
 * @export
 * @param {*} attr
 * @param {string} value
 * @return {string}
 */
XML.prototype.setAttribute = function(attr, value) {
  var /** @type {number} */ i = 0;
  this.getAttributes();
  if (org.apache.royale.utils.Language.is(attr, XML)) {
    if (attr.nodeKind() == "attribute") {
      var /** @type {number} */ len = this.attributeLength();
      for (i = 0; i < len; i++) {
        if (this._attributes[i].name().equals(attr.name())) {
          this._attributes[i].setValue(value);
          return value;
        }
      }
      if (value)
        attr.setValue(value);
      this.addChild(attr);
    }
    return value;
  }
  if (attr.indexOf("xmlns") == 0) {
    var /** @type {Namespace} */ ns = new Namespace(value.toString());
    if (attr.indexOf("xmlns:") == 0)
      ns.prefix = org.apache.royale.utils.Language.string(attr.split(":")[1]);
    this.addNamespace(ns);
  } else {
    var /** @type {QName} */ qname = this.toAttributeName(attr);
    var /** @type {XML} */ attrXML = new XML();
    attrXML.setNodeKind("attribute");
    attrXML.setName(this.toAttributeName(attr));
    attrXML.setValue(value);
    len = this.attributeLength();
    for (i = 0; i < len; i++) {
      if (this._attributes[i].name().equals(attrXML.name())) {
        this._attributes[i].setValue(value);
        return value;
      }
    }
    this.addChild(attrXML);
  }
  return value;
};


/**
 * Replaces the child properties of the XML object with the specified name with the specified XML or XMLList.
 * This is primarily used to support dot notation assignment of XML.
 * 
 * @asparam value
 * @asreturn 
 * 
 * @export
 * @param {*} elementName
 * @param {Object} elements
 * @return {Object}
 */
XML.prototype.setChild = function(elementName, elements) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  var /** @type {XML} */ chld;
  var /** @type {Object} */ retVal = elements;
  var /** @type {XMLList} */ chldrn;
  var /** @type {number} */ childIdx = 0;
  var /** @type {string} */ childType = typeof(elements);
  if (childType != "object") {
    var /** @type {XML} */ stringable = this.xmlFromStringable(elements);
    chldrn = this.child(elementName);
    childIdx = this.children().length() - 1;
    if (chldrn.length())
      childIdx = chldrn[0].childIndex() - 1; else {
      chld = new XML("<" + elementName + "/>");
      chld.appendChild(stringable);
      this.prependChild(chld);
      return chld;
    }
    len = chldrn.length() - 1;
    for (i = len; i > 0; i--) {
      this.removeChild(chldrn[i]);
    }
    chld = chldrn[i];
    chld.setChildren(stringable);
    return chld;
  }
  if (org.apache.royale.utils.Language.is(elements, XML)) {
    var /** @type {XMLList} */ list = new XMLList();
    list[0] = elements;
    elements = list;
  }
  if (org.apache.royale.utils.Language.is(elements, XMLList)) {
    chldrn = this.child(elementName);
    childIdx = this.children().length() - 1;
    if (chldrn.length())
      childIdx = chldrn[0].childIndex() - 1;
    len = chldrn.length() - 1;
    for (i = len; i >= 0; i--) {
      this.removeChild(chldrn[i]);
    }
    var /** @type {XML} */ curChild = this.getChildren()[childIdx];
    len = Number(elements.length());
    for (i = 0; i < len; i++) {
      chld = elements[i];
      if (!curChild) {
        curChild = chld;
        if (childIdx < 0)
          this.prependChild(chld);
        else
          this.appendChild(chld);
      } else {
        this.insertChildAfter(curChild, chld);
        curChild = chld;
      }
    }
  }
  return retVal;
};


/**
 * Replaces the child properties of the XML object with the specified set of XML properties, provided in the value parameter.
 * 
 * @asparam value
 * @asreturn 
 * 
 * @export
 * @param {Object} value
 * @return {XML}
 */
XML.prototype.setChildren = function(value) {
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  var /** @type {XML} */ chld;
  if (org.apache.royale.utils.Language.is(value, XML)) {
    var /** @type {XMLList} */ list = new XMLList();
    list[0] = value;
    value = list;
  }
  if (org.apache.royale.utils.Language.is(value, XMLList)) {
    var /** @type {XMLList} */ chldrn = this.children();
    var /** @type {number} */ childIdx = chldrn.length() - 1;
    if (chldrn.length())
      childIdx = Number(chldrn[0].childIndex());
    len = chldrn.length() - 1;
    for (i = len; i >= 0; i--) {
      this.removeChild(chldrn[i]);
    }
    var /** @type {XML} */ curChild = this.getChildren()[childIdx];
    len = Number(value.length());
    for (i = 0; i < len; i++) {
      chld = value[i];
      if (!curChild) {
        curChild = chld;
        this.appendChild(chld);
      } else {
        this.insertChildAfter(curChild, chld);
        curChild = chld;
      }
    }
  }
  return this;
};


/**
 * Changes the local name of the XML object to the given name parameter.
 * 
 * @asparam name
 * 
 * @export
 * @param {string} name
 */
XML.prototype.setLocalName = function(name) {
  if (!this._name)
    this._name = new QName();
  this._name = XML.getQName(name, this._name.prefix, this._name.uri, this._name.isAttribute);
};


/**
 * Sets the name of the XML object to the given qualified name or attribute name.
 * 
 * @asparam name
 * 
 * @export
 * @param {*} name
 */
XML.prototype.setName = function(name) {
  var /** @type {QName} */ nameRef;
  if (org.apache.royale.utils.Language.is(name, QName))
    nameRef = name;
  else
    nameRef = new QName(name);
  this._name = XML.getQName(nameRef.localName, nameRef.prefix, nameRef.uri, nameRef.isAttribute);
};


/**
 * Sets the namespace associated with the XML object.
 * 
 * @asparam ns
 * 
 * @export
 * @param {Object} ns
 */
XML.prototype.setNamespace = function(ns) {
  if (this._nodeKind == "text" || this._nodeKind == "comment" || this._nodeKind == "processing-instruction")
    return;
  var /** @type {Namespace} */ ns2 = new Namespace(ns);
  var /** @type {QName} */ nameRef = new QName(ns2, this.name());
  if (this._nodeKind == "attribute") {
    nameRef.isAttribute = true;
    if (this._parent == null)
      return;
    this._parent.addNamespace(ns2);
  }
  this._name = XML.getQName(nameRef.localName, nameRef.prefix, nameRef.uri, nameRef.isAttribute);
  if (this._nodeKind == "element")
    this.addNamespace(ns2);
};


/**
 * @asprivate
 * 
 * @export
 * @param {string} value
 */
XML.prototype.setNodeKind = function(value) {
  if (this._nodeKind != value)
    this._nodeKind = value;
};


/**
 * @export
 * @param {XML} parent
 */
XML.prototype.setParent = function(parent) {
  if (parent == this._parent)
    return;
  var /** @type {XML} */ oldParent = this._parent;
  if (oldParent)
    oldParent.removeChild(this);
  this._parent = parent;
};


/**
 * @export
 * @param {string} value
 */
XML.prototype.setValue = function(value) {
  this._value = value;
};


/**
 * Returns an XMLList object of all XML properties of the XML object that represent XML text nodes.
 * 
 * @asreturn 
 * 
 * @export
 * @return {XMLList}
 */
XML.prototype.text = function() {
  var /** @type {XMLList} */ list = new XMLList();
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = this.childrenLength();
  for (i = 0; i < len; i++) {
    if (this._children[i].nodeKind() == "text")
      list.append(this._children[i]);
  }
  list.targetObject = this;
  return list;
};


/**
 * Returns a string representation of the XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @return {string}
 */
XML.prototype.toString = function() {
  var /** @type {number} */ i = 0;
  if (this._nodeKind == "text" || this._nodeKind == "attribute")
    return this._value;
  if (this._nodeKind == "comment")
    return "";
  if (this._nodeKind == "processing-instruction")
    return "";
  if (this.hasSimpleContent()) {
    var /** @type {string} */ s = "";
    var /** @type {number} */ len = this.childrenLength();
    for (i = 0; i < len; i++) {
      if (this._children[i].nodeKind() == "comment" || this._children[i].nodeKind() == "processing-instruction")
        continue;
      s = s + this._children[i].toString();
    }
    return s;
  }
  return this.toXMLString();
};


/**
 * @private
 * @param {*} name
 * @return {QName}
 */
XML.prototype.toAttributeName = function(name) {
  var /** @type {QName} */ qname;
  if (!org.apache.royale.utils.Language.is(name, QName)) {
    name = name.toString();
    if (name.indexOf("@") > -1)
      name = name.substring(name.indexOf("@") + 1);
  }
  qname = this.toXMLName(name);
  qname.isAttribute = true;
  return qname;
};


/**
 * @private
 * @param {*} name
 * @return {QName}
 */
XML.prototype.toXMLName = function(name) {
  var /** @type {QName} */ qname;
  if (name.toString().indexOf("@") > -1)
    return this.toAttributeName(name);
  if (parseInt(name, 10).toString() == name)
    throw new TypeError("invalid element name");
  if (org.apache.royale.utils.Language.is(!name, QName)) {
    name = name.toString();
    if (name.indexOf(":") >= 0) {
      qname = new QName();
      qname.prefix = org.apache.royale.utils.Language.string(name.substring(0, name.indexOf(":")));
      qname.localName = org.apache.royale.utils.Language.string(name.substring(name.lastIndexOf(":") + 1));
      qname.uri = this.getURI(qname.prefix);
    } else {
      qname = new QName(name());
      if (!qname.uri && XML.defaultNamespace) {
        qname = new QName(XML.defaultNamespace);
      }
      qname.localName = org.apache.royale.utils.Language.string(name);
    }
  } else {
    qname = new QName(name);
  }
  return qname;
};


/**
 * Returns a string representation of the XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @param {number=} indentLevel
 * @param {Array=} ancestors
 * @return {string}
 */
XML.prototype.toXMLString = function(indentLevel, ancestors) {
  indentLevel = typeof indentLevel !== 'undefined' ? indentLevel : 0;
  ancestors = typeof ancestors !== 'undefined' ? ancestors : null;
  var /** @type {number} */ i = 0;
  var /** @type {number} */ len = 0;
  var /** @type {Namespace} */ ns;
  var /** @type {Array} */ strArr = [];
  indentLevel = Number(isNaN(indentLevel) ? 0 : indentLevel);
  var /** @type {Array} */ indentArr = [];
  for (i = 0; i < indentLevel; i++)
    indentArr.push(XML._indentStr);
  var /** @type {string} */ indent = indentArr.join("");
  if (this.nodeKind() == "text") {
    if (XML.prettyPrinting) {
      var /** @type {string} */ v = XML.trimXMLWhitespace(this._value);
      if (this.name().localName == "#cdata-section")
        return indent + v;
      return indent + XML.escapeElementValue(v);
    }
    if (this.name().localName == "#cdata-section")
      return this._value;
    return XML.escapeElementValue(this._value);
  }
  if (this.nodeKind() == "attribute")
    return indent + XML.escapeAttributeValue(this._value);
  if (this.nodeKind() == "comment")
    return indent + "<!--" + this._value + "-->";
  if (this.nodeKind() == "processing-instruction")
    return indent + "<?" + this.name().localName + " " + this._value + "?>";
  if (!ancestors)
    ancestors = [];
  var /** @type {Array} */ declarations = [];
  len = this.namespaceLength();
  for (i = 0; i < len; i++) {
    if (!XML.namespaceInArray(this._namespaces[i], ancestors))
      declarations.push(new Namespace(this._namespaces[i]));
  }
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    ns = new Namespace(this._attributes[i].name().getNamespace(ancestors.concat(declarations)));
    if (ns.prefix === null) {
      ns.prefix = "";
      declarations.push(ns);
    }
  }
  ns = new Namespace(this.name().getNamespace(ancestors.concat(declarations)));
  if (ns.prefix === null) {
    ns.prefix = "";
    declarations.push(ns);
  }
  if (XML.prettyPrinting) {
    strArr.push(new Array(indentLevel).join(' '));
  }
  strArr.push("<");
  if (ns.prefix)
    strArr.push(ns.prefix + ":");
  strArr.push(this.name().localName);
  for (i = 0; i < declarations.length; i++) {
    var /** @type {string} */ decVal = XML.escapeAttributeValue(declarations[i].uri);
    if (decVal) {
      strArr.push(" xmlns");
      if (declarations[i].prefix) {
        strArr.push(":");
        strArr.push(declarations[i].prefix);
      }
      strArr.push('="');
      strArr.push(decVal);
      strArr.push('"');
    }
  }
  len = this.attributeLength();
  for (i = 0; i < len; i++) {
    strArr.push(" ");
    var /** @type {QName} */ aName = this._attributes[i].name();
    var /** @type {Namespace} */ ans = aName.getNamespace(ancestors.concat(declarations));
    if (ans.prefix) {
      strArr.push(ans.prefix);
      strArr.push(":");
    }
    strArr.push(aName.localName);
    strArr.push('="');
    strArr.push(XML.escapeAttributeValue(this._attributes[i].getValue()));
    strArr.push('"');
  }
  len = this.childrenLength();
  if (len == 0) {
    strArr.push("/>");
    return strArr.join("");
  }
  strArr.push(">");
  var /** @type {boolean} */ indentChildren = len > 1 || (len == 1 && this._children[0].nodeKind() != "text");
  var /** @type {number} */ nextIndentLevel = 0;
  if (XML.prettyPrinting && indentChildren)
    nextIndentLevel = Number(indentLevel + XML["prettyIndent"]);
  else
    nextIndentLevel = 0;
  for (i = 0; i < len; i++) {
    if (XML.prettyPrinting && indentChildren)
      strArr.push("\n");
    strArr.push(this._children[i].toXMLString(nextIndentLevel, ancestors.concat(declarations)));
  }
  if (XML.prettyPrinting && indentChildren) {
    strArr.push("\n");
    strArr.push(new Array(indentLevel + 1).join(' '));
  }
  strArr.push("</");
  if (ns.prefix) {
    strArr.push(ns.prefix);
    strArr.push(":");
  }
  strArr.push(this.name().localName);
  strArr.push(">");
  return strArr.join("");
};


/**
 * Returns the XML object.
 * 
 * @asreturn 
 * 
 * @export
 * @override
 */
XML.prototype.valueOf = function() {
  var /** @type {string} */ str = this.toString();
  if (str == "")
    return str;
  var /** @type {number} */ num = Number(str);
  return isNaN(num) ? str : num;
};


/**
 * @export
 * @param {number} index
 * @return {string}
 */
XML.prototype.charAt = function(index) {
  return this.s().charAt(index);
};


/**
 * @export
 * @param {number} index
 * @return {number}
 */
XML.prototype.charCodeAt = function(index) {
  return this.s().charCodeAt(index);
};


/**
 * @export
 * @param {number} pos
 * @return {number}
 */
XML.prototype.codePointAt = function(pos) {
  return this.s().codePointAt(pos);
};


/**
 * @export
 * @param {string} searchValue
 * @param {number=} fromIndex
 * @return {number}
 */
XML.prototype.indexOf = function(searchValue, fromIndex) {
  fromIndex = typeof fromIndex !== 'undefined' ? fromIndex : 0;
  return this.s().indexOf(searchValue, fromIndex);
};


/**
 * @export
 * @param {string} searchValue
 * @param {number=} fromIndex
 * @return {number}
 */
XML.prototype.lastIndexOf = function(searchValue, fromIndex) {
  fromIndex = typeof fromIndex !== 'undefined' ? fromIndex : 0;
  return this.s().lastIndexOf(searchValue, fromIndex);
};


/**
 * @export
 * @param {string} compareString
 * @param {*=} locales
 * @param {*=} options
 * @return {number}
 */
XML.prototype.localeCompare = function(compareString, locales, options) {
  locales = typeof locales !== 'undefined' ? locales : undefined;
  options = typeof options !== 'undefined' ? options : undefined;
  return this.s().localeCompare(compareString, locales, options);
};


/**
 * @export
 * @param {*} regexp
 * @return {Array}
 */
XML.prototype.match = function(regexp) {
  return this.s().match(regexp);
};


/**
 * @export
 * @param {*} regexp
 * @return {number}
 */
XML.prototype.search = function(regexp) {
  return this.s().search(regexp);
};


/**
 * @export
 * @param {number} beginSlice
 * @param {*=} endSlice
 * @return {string}
 */
XML.prototype.slice = function(beginSlice, endSlice) {
  endSlice = typeof endSlice !== 'undefined' ? endSlice : undefined;
  return this.s().slice(beginSlice, endSlice);
};


/**
 * @export
 * @param {*=} separator
 * @param {*=} limit
 * @return {Array}
 */
XML.prototype.split = function(separator, limit) {
  separator = typeof separator !== 'undefined' ? separator : undefined;
  limit = typeof limit !== 'undefined' ? limit : undefined;
  return this.s().split(separator, limit);
};


/**
 * @export
 * @param {number} start
 * @param {*=} length
 * @return {string}
 */
XML.prototype.substr = function(start, length) {
  length = typeof length !== 'undefined' ? length : undefined;
  return this.s().substr(start, length);
};


/**
 * @export
 * @param {number} indexStart
 * @param {*=} indexEnd
 * @return {string}
 */
XML.prototype.substring = function(indexStart, indexEnd) {
  indexEnd = typeof indexEnd !== 'undefined' ? indexEnd : undefined;
  return this.s().substring(indexStart, indexEnd);
};


/**
 * @export
 * @return {string}
 */
XML.prototype.toLocaleLowerCase = function() {
  return this.s().toLocaleLowerCase();
};


/**
 * @export
 * @return {string}
 */
XML.prototype.toLocaleUpperCase = function() {
  return this.s().toLocaleUpperCase();
};


/**
 * @export
 * @return {string}
 */
XML.prototype.toLowerCase = function() {
  return this.s().toLowerCase();
};


/**
 * @export
 * @return {string}
 */
XML.prototype.toUpperCase = function() {
  return this.s().toUpperCase();
};


/**
 * @export
 * @return {string}
 */
XML.prototype.trim = function() {
  return this.s().trim();
};


/**
 * @royaleignorecoercion Number
 * @export
 * @param {*=} fractionDigits
 * @return {number}
 */
XML.prototype.toExponential = function(fractionDigits) {
  fractionDigits = typeof fractionDigits !== 'undefined' ? fractionDigits : undefined;
  return this.v().toExponential(fractionDigits);
};


/**
 * @royaleignorecoercion Number
 * @export
 * @param {*=} digits
 * @return {number}
 */
XML.prototype.toFixed = function(digits) {
  digits = typeof digits !== 'undefined' ? digits : undefined;
  return this.v().toFixed(digits);
};


/**
 * @royaleignorecoercion Number
 * @export
 * @param {*=} precision
 * @return {number}
 */
XML.prototype.toPrecision = function(precision) {
  precision = typeof precision !== 'undefined' ? precision : undefined;
  return this.v().toPrecision(precision);
};


/**
 * @private
 * @return {string}
 */
XML.prototype.s = function() {
  return this.toString();
};


/**
 * @private
 * @return {number}
 */
XML.prototype.v = function() {
  return Number(this.s());
};


XML.prototype.get__targetObject = function() {
  return null;
};


Object.defineProperties(XML.prototype, /** @lends {XML.prototype} */ {
/**
  * @export
  * @type {*} */
targetObject: {
get: XML.prototype.get__targetObject}}
);


XML.get__prettyIndent = function() {
  return XML._prettyIndent;
};


XML.set__prettyIndent = function(value) {
  XML._prettyIndent = value;
  XML._indentStr = "";
  for (var /** @type {number} */ i = 0; i < value; i++) {
    XML._indentStr = XML._indentStr + XML.INDENT_CHAR;
  }
};


Object.defineProperties(XML, /** @lends {XML} */ {
/**
  * @export
  * @type {number} */
prettyIndent: {
get: XML.get__prettyIndent,
set: XML.set__prettyIndent}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
XML.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'XML', qName: 'XML', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
XML.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|ignoreComments': { type: 'Boolean'},
        '|ignoreProcessingInstructions': { type: 'Boolean'},
        '|ignoreWhitespace': { type: 'Boolean'},
        '|prettyPrinting': { type: 'Boolean'}
      };
    },
    accessors: function () {
      return {
        '|prettyIndent': { type: 'int', access: 'readwrite', declaredBy: 'XML'},
        'targetObject': { type: '*', access: 'readonly', declaredBy: 'XML'}
      };
    },
    methods: function () {
      return {
        '|clearQNameCache': { type: 'void', declaredBy: 'XML'},
        '|setDefaultNamespace': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        '|defaultSettings': { type: 'Object', declaredBy: 'XML'},
        '|setSettings': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: false } ]; }},
        '|settings': { type: 'Object', declaredBy: 'XML'},
        'XML': { type: '', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: true } ]; }},
        'addChild': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false } ]; }},
        'addNamespace': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Namespace', optional: false } ]; }},
        'appendChild': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'attribute': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'attributes': { type: 'XMLList', declaredBy: 'XML'},
        'child': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: false } ]; }},
        'childIndex': { type: 'int', declaredBy: 'XML'},
        'children': { type: 'XMLList', declaredBy: 'XML'},
        'comments': { type: 'XMLList', declaredBy: 'XML'},
        'concat': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'contains': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'copy': { type: 'XML', declaredBy: 'XML'},
        'descendants': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: true } ]; }},
        'elements': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: true } ]; }},
        'elementNames': { type: 'Array', declaredBy: 'XML'},
        'equals': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'hasAttribute': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'String', optional: true } ]; }},
        'getAttributeArray': { type: 'Array', declaredBy: 'XML'},
        'getChildrenArray': { type: 'Array', declaredBy: 'XML'},
        'getIndexOf': { type: 'int', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false } ]; }},
        'getValue': { type: 'String', declaredBy: 'XML'},
        'hasAncestor': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'hasComplexContent': { type: 'Boolean', declaredBy: 'XML'},
        'hasOwnProperty': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'hasSimpleContent': { type: 'Boolean', declaredBy: 'XML'},
        'inScopeNamespaces': { type: 'Array', declaredBy: 'XML'},
        'insertChildAfter': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false },{ index: 2, type: 'XML', optional: false } ]; }},
        'insertChildBefore': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false },{ index: 2, type: 'XML', optional: false } ]; }},
        'length': { type: 'int', declaredBy: 'XML'},
        'localName': { type: 'Object', declaredBy: 'XML'},
        'name': { type: 'Object', declaredBy: 'XML'},
        'namespace': { type: '*', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: true } ]; }},
        'namespaceDeclarations': { type: 'Array', declaredBy: 'XML'},
        'nodeKind': { type: 'String', declaredBy: 'XML'},
        'normalize': { type: 'XML', declaredBy: 'XML'},
        'parent': { type: '*', declaredBy: 'XML'},
        'plus': { type: '*', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'prependChild': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false } ]; }},
        'processingInstructions': { type: 'XMLList', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: true } ]; }},
        'removeChild': { type: 'Boolean', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false } ]; }},
        'removeChildAt': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'int', optional: false } ]; }},
        'removeNamespace': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'replace': { type: '*', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: '*', optional: false } ]; }},
        'replaceChildAt': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'int', optional: false },{ index: 2, type: '*', optional: false } ]; }},
        'setAttribute': { type: 'String', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'String', optional: false } ]; }},
        'setChild': { type: 'Object', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'Object', optional: false } ]; }},
        'setChildren': { type: 'XML', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: false } ]; }},
        'setLocalName': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'setName': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'setNamespace': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Object', optional: false } ]; }},
        'setNodeKind': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'setParent': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'XML', optional: false } ]; }},
        'setValue': { type: 'void', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'text': { type: 'XMLList', declaredBy: 'XML'},
        'toString': { type: 'String', declaredBy: 'XML'},
        'toXMLString': { type: 'String', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'int', optional: true },{ index: 2, type: 'Array', optional: true } ]; }},
        'valueOf': { type: '*', declaredBy: 'XML'},
        'charAt': { type: 'String', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Number', optional: false } ]; }},
        'charCodeAt': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Number', optional: false } ]; }},
        'codePointAt': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Number', optional: false } ]; }},
        'indexOf': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'Number', optional: true } ]; }},
        'lastIndexOf': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'Number', optional: true } ]; }},
        'localeCompare': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: '*', optional: true },{ index: 3, type: '*', optional: true } ]; }},
        'match': { type: 'Array', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'search': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        'slice': { type: 'String', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'split': { type: 'Array', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: true },{ index: 2, type: '*', optional: true } ]; }},
        'substr': { type: 'String', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'substring': { type: 'String', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'toLocaleLowerCase': { type: 'String', declaredBy: 'XML'},
        'toLocaleUpperCase': { type: 'String', declaredBy: 'XML'},
        'toLowerCase': { type: 'String', declaredBy: 'XML'},
        'toUpperCase': { type: 'String', declaredBy: 'XML'},
        'trim': { type: 'String', declaredBy: 'XML'},
        'toExponential': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: true } ]; }},
        'toFixed': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: true } ]; }},
        'toPrecision': { type: 'Number', declaredBy: 'XML', parameters: function () { return [  { index: 1, type: '*', optional: true } ]; }}
      };
    }
  };
};
