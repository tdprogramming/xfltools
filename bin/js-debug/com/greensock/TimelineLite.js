/**
 * Generated by Apache Royale Compiler from com\greensock\TimelineLite.as
 * com.greensock.TimelineLite
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('com.greensock.TimelineLite');
/* Royale Dependency List: com.greensock.TweenLite,com.greensock.core.Animation,org.apache.royale.utils.Language,XML*/

goog.require('com.greensock.core.SimpleTimeline');



/**
 * Constructor.
 * 
 * <p><strong>SPECIAL PROPERTIES</strong></p>
 * <p>The following special properties may be passed in via the constructor's vars parameter, like
 * <code>new TimelineLite({paused:true, onComplete:myFunction})</code></p>
 * 
 * <ul>
 * 	<li><strong> delay </strong>:<em> Number</em> -
 * 				 Amount of delay in seconds (or frames for frames-based tweens) before the timeline should begin.</li>
 * 
 *  <li><strong> paused </strong>:<em> Boolean</em> -
 * 				 If <code>true</code>, the timeline will pause itself immediately upon creation (by default, 
 * 				 timelines automatically begin playing immediately). If you plan to create a TimelineLite and 
 * 				 then populate it later (after one or more frames elapse), it is typically best to set 
 * 				 <code>paused:true</code> and then <code>play()</code> after you populate it.</li>
 * 	
 * 	<li><strong> onComplete </strong>:<em> Function</em> -
 * 				 A function that should be called when the timeline has completed</li>
 * 	
 * 	<li><strong> onCompleteParams </strong>:<em> Array</em> -
 * 				 An Array of parameters to pass the <code>onComplete</code> function. For example,
 * 				 <code>new TimelineLite({onComplete:myFunction, onCompleteParams:["param1", "param2"]});</code></li>
 * 	
 * 	<li><strong> useFrames </strong>:<em> Boolean</em> -
 * 				 If <code>useFrames</code> is <code>true</code>, the timelines's timing will be 
 * 				 based on frames instead of seconds because it is intially added to the root
 * 				 frames-based timeline. This causes both its <code>duration</code>
 * 				 and <code>delay</code> to be based on frames. An animations's timing mode is 
 * 				 always determined by its parent <code>timeline</code>.</li>
 * 
 *  <li><strong> tweens </strong>:<em> Array</em> -
 * 				 To immediately insert several tweens into the timeline, use the <code>tweens</code> 
 * 				 special property to pass in an Array of TweenLite/TweenMax/TimelineLite/TimelineMax 
 * 				 instances. You can use this in conjunction with the <code>align</code> and 
 * 				 <code>stagger</code> special properties to set up complex sequences with minimal code.
 * 				 These values simply get passed to the <code>add()</code> method.</li>
 * 	
 * 	<li><strong> align </strong>:<em> String</em> -
 * 				 Only used in conjunction with the <code>tweens</code> special property when multiple 
 * 				 tweens are	to be inserted immediately. The value simply gets passed to the 
 * 				 <code>add()</code> method. The default is <code>"normal"</code>. 
 * 				 Options are:
 * 					<ul>
 * 						<li><strong><code>"sequence"</code></strong>: aligns the tweens one-after-the-other in a sequence</li>
 * 						<li><strong><code>"start"</code></strong>: aligns the start times of all of the tweens (ignores delays)</li>
 * 						<li><strong><code>"normal"</code></strong>: aligns the start times of all the tweens (honors delays)</li>
 * 					</ul>
 * 				The <code>align</code> special property does <strong>not</strong> force all child 
 * 				tweens/timelines to maintain relative positioning, so for example, if you use 
 * 				<code>"sequence"</code> and then later change the duration of one of the nested tweens, 
 * 				it does <strong>not</strong> force all subsequent timelines to change their position.
 * 				The <code>align</code> special property only affects the alignment of the tweens that are
 * 				initially placed into the timeline through the <code>tweens</code> special property of 
 * 				the <code>vars</code> object.</li>
 * 										
 * 	<li><strong> stagger </strong>:<em> Number</em> -
 * 				 Only used in conjunction with the <code>tweens</code> special property when multiple 
 * 				 tweens are	to be inserted immediately. It staggers the tweens by a set amount of time 
 * 				 in seconds (or in frames if <code>useFrames</code> is true). For example, if the 
 * 				 stagger value is 0.5 and the "align" property is set to <code>"start"</code>, the 
 * 				 second tween will start 0.5 seconds after the first one starts, then 0.5 seconds 
 * 				 later the third one will start, etc. If the align property is <code>"sequence"</code>,
 * 				 there would be 0.5 seconds added between each tween. This value simply gets 
 * 				 passed to the <code>add()</code> method. Default is 0.</li>
 * 
 *  <li><strong> onStart </strong>:<em> Function</em> -
 * 				 A function that should be called when the timeline begins (when its <code>time</code>
 * 				 changes from 0 to some other value which can happen more than once if the 
 * 				 timeline is restarted multiple times).</li>
 * 	
 * 	<li><strong> onStartParams </strong>:<em> Array</em> -
 * 				 An Array of parameters to pass the <code>onStart</code> function. For example, 
 * 				 <code>new TimelineLite({onStart:myFunction, onStartParams:["param1", "param2"]});</code></li>
 * 	
 * 	<li><strong> onUpdate </strong>:<em> Function</em> -
 * 				 A function that should be called every time the timeline updates  
 * 				 (on every frame while the timeline is active)</li>
 * 	
 * 	<li><strong> onUpdateParams </strong>:<em> Array</em> -
 * 				 An Array of parameters to pass the <code>onUpdate</code> function. For example,
 * 				 <code>new TimelineLite({onUpdate:myFunction, onUpdateParams:["param1", "param2"]});</code></li>
 * 	
 * 	<li><strong> onReverseComplete </strong>:<em> Function</em> -
 * 				 A function that should be called when the timeline has reached its beginning again from the 
 * 				 reverse direction. For example, if <code>reverse()</code> is called, the timeline will move
 * 				 back towards its beginning and when its <code>time</code> reaches 0, <code>onReverseComplete</code>
 * 				 will be called. This can also happen if the timeline is placed in a TimelineLite or TimelineMax 
 * 				 instance that gets reversed and plays the timeline backwards to (or past) the beginning.</li>
 * 	
 * 	<li><strong> onReverseCompleteParams </strong>:<em> Array</em> -
 * 				 An Array of parameters to pass the <code>onReverseComplete</code> function. For example, 
 * 				 <code>new TimelineLite({onReverseComplete:myFunction, onReverseCompleteParams:["param1", "param2"]});</code></li>
 * 
 * <li><strong> autoRemoveChildren </strong>:<em> Boolean</em> -
 * 				If <code>autoRemoveChildren</code> is set to <code>true</code>, as soon as child 
 * 				tweens/timelines complete, they will automatically get killed/removed. This is normally 
 * 				undesireable because it prevents going backwards in time (like if you want to 
 * 				<code>reverse()</code> or set the <code>progress</code> lower, etc.). It can, however, 
 * 				improve speed and memory management. The root timelines use <code>autoRemoveChildren:true</code>.</li>
 * 
 * <li><strong> smoothChildTiming </strong>:<em> Boolean</em> -
 * 				Controls whether or not child tweens/timelines are repositioned automatically 
 * 				(changing their <code>startTime</code>) in order to maintain smooth playback when 
 * 				properties are changed on-the-fly. For example, imagine that the timeline's playhead is 
 * 				on a child tween that is 75% complete, moving mc.x from 0 to 100 and then that tween's 
 * 				<code>reverse()</code> method is called. If <code>smoothChildTiming</code> is <code>false</code> 
 * 				(the default except for the root timelines), the tween would flip in place, keeping its 
 * 				<code>startTime</code> consistent. Therefore the playhead of the timeline would now be 
 * 				at the tween's 25% completion point instead of 75%. Remember, the timeline's playhead 
 * 				position and direction are unaffected by child tween/timeline changes. mc.x would jump 
 * 				from 75 to 25, but the tween's position in the timeline would remain consistent. However, 
 * 				if <code>smoothChildTiming</code> is <code>true</code>, that child tween's 
 * 				<code>startTime</code> would be adjusted so that the timeline's playhead intersects 
 * 				with the same spot on the tween (75% complete) as it had immediately before 
 * 				<code>reverse()</code> was called, thus playback appears perfectly smooth. mc.x 
 * 				would still be 75 and it would continue from there as the playhead moves on, but 
 * 				since the tween is reversed now mc.x will travel back towards 0 instead of 100. 
 * 				Ultimately it's a decision between prioritizing smooth on-the-fly playback 
 * 				(<code>true</code>) or consistent position(s) of child tweens/timelines 
 * 				(<code>false</code>). 
 * 
 * 				Some examples of on-the-fly changes to child tweens/timelines that could cause their 
 * 				<code>startTime</code> to change when <code>smoothChildTiming</code> is <code>true</code> 
 * 				are: <code>reversed, timeScale, progress, totalProgress, time, totalTime, delay, pause, 
 * 				resume, duration,</code> and <code>totalDuration</code>.</li>
 * 	
 * 	</ul>
 * 
 * @asparam vars optionally pass in special properties like <code>onComplete, onCompleteParams, onUpdate, onUpdateParams, onStart, onStartParams, tweens, align, stagger, delay, useFrames,</code> and/or <code>autoRemoveChildren</code>.
 * @constructor
 * @extends {com.greensock.core.SimpleTimeline}
 * @param {Object=} vars
 */
com.greensock.TimelineLite = function(vars) {
  vars = typeof vars !== 'undefined' ? vars : null;
  com.greensock.TimelineLite.base(this, 'constructor', vars);
  this._labels = {};
  this.autoRemoveChildren = (this.vars.autoRemoveChildren == true);
  this.smoothChildTiming = (this.vars.smoothChildTiming == true);
  this._sortChildren = true;
  this._onUpdate = this.vars.onUpdate;
  var /** @type {Object} */ val, /** @type {string} */ p;
  for (p in this.vars) {
    val = this.vars[p];
    if (org.apache.royale.utils.Language.is(val, Array))
      if (val.join("").indexOf("{self}") !== -1) {
        this.vars[p] = this._swapSelfInParams(org.apache.royale.utils.Language.as(val, Array));
      }
  }
  if (org.apache.royale.utils.Language.is(this.vars.tweens, Array)) {
    this.add(this.vars.tweens, 0, this.vars.align || "normal", this.vars.stagger || 0);
  }
};
goog.inherits(com.greensock.TimelineLite, com.greensock.core.SimpleTimeline);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('com.greensock.TimelineLite', com.greensock.TimelineLite);


/**
 * @export
 * @const
 * @type {string}
 */
com.greensock.TimelineLite.version = "12.1.5";


/**
 * @protected
 * @type {Object}
 */
com.greensock.TimelineLite.prototype._labels;


/**
 * Adds a <code>TweenLite.to()</code> tween to the end of the timeline (or elsewhere using the "position" parameter)
 *  - this is a convenience method that accomplishes exactly the same thing as 
 * <code>add( TweenLite.to(...) )</code> but with less code. In other 
 * words, the following two lines produce identical results:
 * 
 * <listing version="3.0">
 
 
 
 * <p>Keep in mind that you can chain these calls together and use other convenience 
 * methods like <code>fromTo(), call(), set(), staggerTo()</code>, etc. to build out 
 * sequences very quickly:</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 * <p>If you don't want to append the tween and would rather have precise control
 * of the insertion point, you can use the additional <code>position</code> parameter. 
 * Or use a regular <code>add()</code> like 
 * <code>myTimeline.add( TweenLite.to(mc, 1, {x:100}), 2.75)</code>.</p>
 * 
 * <p>The 4th parameter is the <code>position</code> which controls the placement of the
 * tween in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tween 
 * which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * @asparam target Target object (or array of objects) whose properties the tween affects 
 * @asparam duration Duration in seconds (or frames if the timeline is frames-based)
 * @asparam vars An object defining the end value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> to 100 and <code>mc.y</code> to 200 and then call <code>myFunction</code>, do this: <code>myTimeline.to(mc, 1, {x:100, y:200, onComplete:myFunction})</code>.
 * @asparam position Controls the placement of the tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asreturn self (makes chaining easier)
 * @see #from()
 * @see #fromTo()
 * @see #add()
 * @see #remove()
 * @export
 * @param {Object} target
 * @param {number} duration
 * @param {Object} vars
 * @param {*=} position
 * @return {*}
 */
com.greensock.TimelineLite.prototype.to = function(target, duration, vars, position) {
  position = typeof position !== 'undefined' ? position : "+=0";
  return duration ? this.add(new com.greensock.TweenLite(target, duration, vars), position) : this.set(target, vars, position);
};


/**
 * Adds a <code>TweenLite.from()</code> tween to the end of the timeline (or elsewhere using the "position" parameter)
 * - this is a convenience method that accomplishes exactly the same thing as 
 * <code>add( TweenLite.from(...) )</code> but with less code. In other 
 * words, the following two lines produce identical results:
 * 
 * <listing version="3.0">
 
 
 
 * <p>Keep in mind that you can chain these calls together and use other convenience 
 * methods like <code>to(), call(), set(), staggerTo()</code>, etc. to build out 
 * sequences very quickly:</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 * <p>If you don't want to append the tween and would rather have precise control
 * of the insertion point, you can use the additional <code>position</code> parameter. 
 * Or use a regular <code>add()</code> like 
 * <code>myTimeline.add( TweenLite.from(mc, 1, {x:100}), 2.75)</code>.</p>
 * 
 * <p>The 4th parameter is the <code>position</code> which controls the placement of the
 * tween in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tween 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * <p><strong>NOTE:</strong> By default, <code>immediateRender</code> is <code>true</code> in 
 * <code>from()</code> tweens, meaning that they immediately render their starting state 
 * regardless of any delay that is specified. You can override this behavior by passing 
 * <code>immediateRender:false</code> in the <code>vars</code> parameter so that it will 
 * wait to render until the tween actually begins.</p>
 * 
 * @asparam target Target object (or array of objects) whose properties the tween affects 
 * @asparam duration Duration in seconds (or frames if the timeline is frames-based)
 * @asparam vars An object defining the starting value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> from 100 and <code>mc.y</code> from 200 and then call <code>myFunction</code>, do this: <code>myTimeline.from(mc, 1, {x:100, y:200, onComplete:myFunction});</code>
 * @asparam position Controls the placement of the tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asreturn self (makes chaining easier)
 * @see #to()
 * @see #fromTo()
 * @see #add()
 * @see #remove()
 * @export
 * @param {Object} target
 * @param {number} duration
 * @param {Object} vars
 * @param {*=} position
 * @return {*}
 */
com.greensock.TimelineLite.prototype.from = function(target, duration, vars, position) {
  position = typeof position !== 'undefined' ? position : "+=0";
  return this.add(com.greensock.TweenLite.from(target, duration, vars), position);
};


/**
 * Adds a <code>TweenLite.fromTo()</code> tween to the end of the timeline - this is 
 * a convenience method that accomplishes exactly the same thing as 
 * <code>add( TweenLite.fromTo(...) )</code> but with less code. In other 
 * words, the following two lines produce identical results:
 * 
 * <listing version="3.0">
 
 
 
 * <p>Keep in mind that you can chain these calls together and use other convenience 
 * methods like <code>to(), call(), set(), staggerTo()</code>, etc. to build out 
 * sequences very quickly:</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 * <p>If you don't want to append the tween and would rather have precise control
 * of the insertion point, you can use the additional <code>position</code> parameter. 
 * Or use a regular <code>add()</code> like 
 * <code>myTimeline.add( TweenLite.fromTo(mc, 1, {x:0}, {x:100}), 2.75)</code>.</p>
 * 
 * <p>The 4th parameter is the <code>position</code> which controls the placement of the
 * tween in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tween 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * <p><strong>NOTE:</strong> by default, <code>immediateRender</code> is <code>true</code> in 
 * <code>fromTo()</code> tweens, meaning that they immediately render their starting state 
 * regardless of any delay that is specified. This is done for convenience because it is 
 * often the preferred behavior when setting things up on the screen to animate into place, but 
 * you can override this behavior by passing <code>immediateRender:false</code> in the 
 * <code>fromVars</code> or <code>toVars</code> parameter so that it will wait to render 
 * the starting values until the tweens actually begin.</p>
 * 
 * @asparam target Target object (or array of objects) whose properties the tween affects
 * @asparam duration Duration in seconds (or frames if the timeline is frames-based)
 * @asparam fromVars An object defining the starting value for each property that should be tweened. For example, to tween <code>mc.x</code> from 100 and <code>mc.y</code> from 200, <code>fromVars</code> would look like this: <code>{x:100, y:200}</code>.
 * @asparam toVars An object defining the end value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> from 0 to 100 and <code>mc.y</code> from 0 to 200 and then call <code>myFunction</code>, do this: <code>myTimeline.fromTo(mc, 1, {x:0, y:0}, {x:100, y:200, onComplete:myFunction});</code>
 * @asparam position Controls the placement of the tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asreturn self (makes chaining easier)
 * @see #to()
 * @see #from()
 * @see #add()
 * @see #remove()
 * @export
 * @param {Object} target
 * @param {number} duration
 * @param {Object} fromVars
 * @param {Object} toVars
 * @param {*=} position
 * @return {*}
 */
com.greensock.TimelineLite.prototype.fromTo = function(target, duration, fromVars, toVars, position) {
  position = typeof position !== 'undefined' ? position : "+=0";
  return duration ? this.add(com.greensock.TweenLite.fromTo(target, duration, fromVars, toVars), position) : this.set(target, toVars, position);
};


/**
 * Tweens an array of targets to a common set of destination values, but staggers their
 * start times by a specified amount of time, creating an evenly-spaced sequence with a
 * surprisingly small amount of code. For example, let's say you have an array containing
 * references to a bunch of text fields that you'd like to fall away and fade out in a
 * staggered fashion with 0.2 seconds between each tween's start time:
 * 
 * <listing version="3.0">
 
 
 
 * <p><code>staggerTo()</code> simply loops through the <code>targets</code> array and creates 
 * a <code>to()</code> tween for each object and then inserts it at the appropriate place on a 
 * new TimelineLite instance whose onComplete corresponds to the <code>onCompleteAll</code> 
 * (if you define one) and then appends that TimelineLite to the timeline (as a nested child).</p>
 * 
 * <p>Note that if you define an <code>onComplete</code> (or any callback for that matter)
 * in the <code>vars</code> parameter, it will be called for each tween rather than the whole 
 * sequence. This can be very useful, but if you want to call a function after the entire
 * sequence of tweens has completed, use the <code>onCompleteAll</code> parameter (the 6th parameter).</p>
 * 
 * <p>The 5th parameter is the <code>position</code> which controls the placement of the
 * tweens in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the first tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the first tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the first tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tweens 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * <p><strong>JavaScript and AS2 note:</strong> - Due to the way JavaScript and AS2 don't 
 * maintain scope (what "<code>this</code>" refers to, or the context) in function calls, 
 * it can be useful to define the scope specifically. Therefore, in the JavaScript and AS2 
 * versions accept an extra (8th) parameter for <code>onCompleteAllScope</code>.</p>
 * 
 * @asparam targets An array of target objects whose properties should be affected
 * @asparam duration Duration in seconds (or frames if the timeline is frames-based)
 * @asparam vars An object defining the end value for each property that should be tweened as well as any special properties like <code>ease</code>. For example, to tween <code>x</code> to 100 and <code>y</code> to 200 for mc1, mc2, and mc3, staggering their start time by 0.25 seconds and then call <code>myFunction</code> when they last one has finished, do this: <code>myTimeline.staggerTo([mc1, mc2, mc3], 1, {x:100, y:200}, 0.25, 0, null, myFunction})</code>.
 * @asparam stagger Amount of time in seconds (or frames if the timeline is frames-based) to stagger the start time of each tween. For example, you might want to have 5 objects move down 100 pixels while fading out, and stagger the start times by 0.2 seconds - you could do: <code>myTimeline.staggerTo([mc1, mc2, mc3, mc4, mc5], 1, {y:"+=100", alpha:0}, 0.2)</code>.
 * @asparam position Controls the placement of the first tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asparam onCompleteAll A function to call as soon as the entire sequence of tweens has completed
 * @asparam onCompleteAllParams An array of parameters to pass the <code>onCompleteAll</code> method.
 * @asreturn self (makes chaining easier) 
 * @see #staggerFrom()
 * @see #staggerFromTo()
 * @export
 * @param {Array} targets
 * @param {number} duration
 * @param {Object} vars
 * @param {number} stagger
 * @param {*=} position
 * @param {Function=} onCompleteAll
 * @param {Array=} onCompleteAllParams
 * @return {*}
 */
com.greensock.TimelineLite.prototype.staggerTo = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
  position = typeof position !== 'undefined' ? position : "+=0";
  onCompleteAll = typeof onCompleteAll !== 'undefined' ? onCompleteAll : null;
  onCompleteAllParams = typeof onCompleteAllParams !== 'undefined' ? onCompleteAllParams : null;
  var /** @type {com.greensock.TimelineLite} */ tl = new com.greensock.TimelineLite({onComplete:onCompleteAll, onCompleteParams:onCompleteAllParams, smoothChildTiming:this.smoothChildTiming});
  for (var /** @type {number} */ i = 0; i < targets.length; i++) {
    if (vars.startAt != null) {
      vars.startAt = com.greensock.TimelineLite._copy(vars.startAt);
    }
    tl.to(targets[i], duration, com.greensock.TimelineLite._copy(vars), i * stagger);
  }
  return this.add(tl, position);
};


/**
 * Tweens an array of targets from a common set of destination values (using the current
 * values as the destination), but staggers their start times by a specified amount of time, 
 * creating an evenly-spaced sequence with a surprisingly small amount of code. For example, 
 * let's say you have an array containing references to a bunch of text fields that you'd 
 * like to drop into place while fading in, all in a staggered fashion with 0.2 seconds 
 * between each tween's start time:
 * 
 * <listing version="3.0">
 
 
 
 * <p><code>staggerFrom()</code> simply loops through the <code>targets</code> array and creates 
 * a <code>from()</code> tween for each object and then inserts it at the appropriate place on a 
 * new TimelineLite instance whose onComplete corresponds to the <code>onCompleteAll</code> 
 * (if you define one) and then appends that TimelineLite to the timeline (as a nested child).</p>
 * 
 * <p>Note that if you define an <code>onComplete</code> (or any callback for that matter)
 * in the <code>vars</code> parameter, it will be called for each tween rather than the whole 
 * sequence. This can be very useful, but if you want to call a function after the entire
 * sequence of tweens has completed, use the <code>onCompleteAll</code> parameter (the 6th parameter).</p>
 * 
 * <p>The 5th parameter is the <code>position</code> which controls the placement of the
 * tweens in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the first tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the first tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the first tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tweens 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * <p>By default, <code>immediateRender</code> is <code>true</code> in 
 * <code>from()</code> tweens, meaning that they immediately render their starting state 
 * regardless of any delay that is specified. You can override this behavior by passing 
 * <code>immediateRender:false</code> in the <code>vars</code> parameter so that it will 
 * wait to render until the tween actually begins.</p>
 * 
 * <p><strong>JavaScript and AS2 note:</strong> - Due to the way JavaScript and AS2 don't 
 * maintain scope (what "<code>this</code>" refers to, or the context) in function calls, 
 * it can be useful to define the scope specifically. Therefore, in the JavaScript and AS2 
 * versions accept an extra (8th) parameter for <code>onCompleteAllScope</code>.</p>
 * 
 * @asparam targets An array of target objects whose properties should be affected
 * @asparam duration Duration in seconds (or frames if the timeline is frames-based)
 * @asparam vars An object defining the beginning value for each property that should be tweened as well as any special properties like <code>ease</code>. For example, to tween <code>x</code> from 100 and <code>y</code> from 200 for mc1, mc2, and mc3, staggering their start time by 0.25 seconds and then call <code>myFunction</code> when they last one has finished, do this: <code>myTimeline.staggerFrom([mc1, mc2, mc3], 1, {x:100, y:200}, 0.25, 0, null, myFunction})</code>.
 * @asparam stagger Amount of time in seconds (or frames if the timeline is frames-based) to stagger the start time of each tween. For example, you might want to have 5 objects move down 100 pixels while fading out, and stagger the start times by 0.2 seconds - you could do: <code>myTimeline.staggerTo([mc1, mc2, mc3, mc4, mc5], 1, {y:"+=100", alpha:0}, 0.2)</code>.
 * @asparam position Controls the placement of the first tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asparam onCompleteAll A function to call as soon as the entire sequence of tweens has completed
 * @asparam onCompleteAllParams An array of parameters to pass the <code>onCompleteAll</code> method.
 * @asreturn self (makes chaining easier) 
 * @see #staggerTo()
 * @see #staggerFromTo()
 * @export
 * @param {Array} targets
 * @param {number} duration
 * @param {Object} vars
 * @param {number=} stagger
 * @param {*=} position
 * @param {Function=} onCompleteAll
 * @param {Array=} onCompleteAllParams
 * @return {*}
 */
com.greensock.TimelineLite.prototype.staggerFrom = function(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
  stagger = typeof stagger !== 'undefined' ? stagger : 0;
  position = typeof position !== 'undefined' ? position : "+=0";
  onCompleteAll = typeof onCompleteAll !== 'undefined' ? onCompleteAll : null;
  onCompleteAllParams = typeof onCompleteAllParams !== 'undefined' ? onCompleteAllParams : null;
  vars = com.greensock.TimelineLite._prepVars(vars);
  if (!("immediateRender" in vars)) {
    vars.immediateRender = true;
  }
  vars.runBackwards = true;
  return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
};


/**
 * Tweens an array of targets from and to a common set of values, but staggers their
 * start times by a specified amount of time, creating an evenly-spaced sequence with a
 * surprisingly small amount of code. For example, let's say you have an array containing
 * references to a bunch of text fields that you'd like to fade from alpha:1 to alpha:0 in a
 * staggered fashion with 0.2 seconds between each tween's start time:
 * 
 * <listing version="3.0">
 
 
 
 * <p><code>staggerFromTo()</code> simply loops through the <code>targets</code> array and creates 
 * a <code>fromTo()</code> tween for each object and then inserts it at the appropriate place on 
 * a new TimelineLite instance whose onComplete corresponds to the <code>onCompleteAll</code> 
 * (if you define one) and then appends that TimelineLite to the timeline (as a nested child).</p>
 * 
 * <p>Note that if you define an <code>onComplete</code> (or any callback for that matter)
 * in the <code>vars</code> parameter, it will be called for each tween rather than the whole 
 * sequence. This can be very useful, but if you want to call a function after the entire
 * sequence of tweens has completed, use the <code>onCompleteAll</code> parameter (the 7th parameter).</p>
 * 
 * <p>The 6th parameter is the <code>position</code> which controls the placement of the
 * tweens in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the first tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the first tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the first tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tweens 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * <p><strong>JavaScript and AS2 note:</strong> - Due to the way JavaScript and AS2 don't 
 * maintain scope (what "<code>this</code>" refers to, or the context) in function calls, 
 * it can be useful to define the scope specifically. Therefore, in the JavaScript and AS2 
 * versions accept an extra (9th) parameter for <code>onCompleteAllScope</code>.</p>
 * 
 * @asparam targets An array of target objects whose properties should be affected
 * @asparam duration Duration in seconds (or frames if the timeline is frames-based)
 * @asparam fromVars An object defining the starting value for each property that should be tweened. For example, to tween <code>x</code> from 100 and <code>y</code> from 200, <code>fromVars</code> would look like this: <code>{x:100, y:200}</code>.
 * @asparam toVars An object defining the end value for each property that should be tweened as well as any special properties like <code>ease</code>. For example, to tween <code>x</code> from 0 to 100 and <code>y</code> from 0 to 200, staggering the start times by 0.2 seconds and then call <code>myFunction</code> when they all complete, do this: <code>myTimeline.staggerFromTo([mc1, mc2, mc3], 1, {x:0, y:0}, {x:100, y:200}, 0.2, 0, null, myFunction});</code>
 * @asparam stagger Amount of time in seconds (or frames if the timeline is frames-based) to stagger the start time of each tween. For example, you might want to have 5 objects move down 100 pixels while fading out, and stagger the start times by 0.2 seconds - you could do: <code>myTimeline.staggerTo([mc1, mc2, mc3, mc4, mc5], 1, {y:"+=100", alpha:0}, 0.2)</code>.
 * @asparam position Controls the placement of the first tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asparam onCompleteAll A function to call as soon as the entire sequence of tweens has completed
 * @asparam onCompleteAllParams An array of parameters to pass the <code>onCompleteAll</code> method.
 * @asreturn self (makes chaining easier) 
 * @see #staggerTo()
 * @see #staggerFrom()
 * @export
 * @param {Array} targets
 * @param {number} duration
 * @param {Object} fromVars
 * @param {Object} toVars
 * @param {number=} stagger
 * @param {*=} position
 * @param {Function=} onCompleteAll
 * @param {Array=} onCompleteAllParams
 * @return {*}
 */
com.greensock.TimelineLite.prototype.staggerFromTo = function(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
  stagger = typeof stagger !== 'undefined' ? stagger : 0;
  position = typeof position !== 'undefined' ? position : "+=0";
  onCompleteAll = typeof onCompleteAll !== 'undefined' ? onCompleteAll : null;
  onCompleteAllParams = typeof onCompleteAllParams !== 'undefined' ? onCompleteAllParams : null;
  toVars = com.greensock.TimelineLite._prepVars(toVars);
  fromVars = com.greensock.TimelineLite._prepVars(fromVars);
  toVars.startAt = fromVars;
  toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
  return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
};


/**
 * Adds a callback to the end of the timeline (or elsewhere using the "position" parameter)
 *  - this is a convenience method that accomplishes exactly the same thing as 
 * <code>add( TweenLite.delayedCall(...) )</code> but with less code. In other 
 * words, the following two lines produce identical results:
 * 
 * <listing version="3.0">
 
 
 
 * <p>This is different than using the <code>onComplete</code> special property
 * on the TimelineLite itself because once you append the callback, it stays in 
 * place whereas an <code>onComplete</code> is always called at the very end of 
 * the timeline. For example, if a timeline is populated with a 1-second tween and 
 * then you <code>call(myFunction)</code>, it is placed at the 1-second spot. Then 
 * if you append another 1-second tween, the timeline's duration will now be 2 seconds 
 * but the myFunction callback will still be called at the 1-second spot. An 
 * <code>onComplete</code> would be called at the end (2 seconds).</p>
 * 
 * <p>Keep in mind that you can chain these calls together and use other convenience 
 * methods like <code>to(), fromTo(), set(), staggerTo()</code>, etc. to build out 
 * sequences very quickly:</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 * 
 * <p>The 3rd parameter is the <code>position</code> which controls the placement of the
 * tween in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tween 
 * which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * <p><strong>JavaScript and AS2 note:</strong> - Due to the way JavaScript and AS2 don't 
 * maintain scope (what "<code>this</code>" refers to, or the context) in function calls, 
 * it can be useful to define the scope specifically. Therefore, in the JavaScript and AS2 
 * versions the 3rd parameter is <code>scope</code>, but that parameter is omitted in the AS3 version.</p>
 * 
 * @asparam callback Function to call
 * @asparam params An Array of parameters to pass the function.
 * @asparam position Controls the placement of the callback in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the callback 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the callback inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the callback 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the callback there which can be quite convenient.
 * @asreturn self (makes chaining easier)
 * @see #add()
 * @see #remove()
 * @export
 * @param {Function} callback
 * @param {Array=} params
 * @param {*=} position
 * @return {*}
 */
com.greensock.TimelineLite.prototype.call = function(callback, params, position) {
  params = typeof params !== 'undefined' ? params : null;
  position = typeof position !== 'undefined' ? position : "+=0";
  return this.add(com.greensock.TweenLite.delayedCall(0, callback, params), position);
};


/**
 * Adds a zero-duration tween to the end of the timeline (or elsewhere using the "position" parameter)
 * that sets values immediately (when the virtual playhead reaches that position
 * on the timeline) - this is a convenience method that accomplishes exactly 
 * the same thing as <code>add( TweenLite.to(target, 0, {...}) )</code> but 
 * with less code. In other words, the following two lines produce identical results:
 * 
 * <listing version="3.0">
 
 
 
 * <p>Keep in mind that you can chain these calls together and use other convenience 
 * methods like <code>to(), call(), fromTo(), staggerTo()</code>, etc. to build out 
 * sequences very quickly:</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 * <p>The 3rd parameter is the <code>position</code> which controls the placement of the
 * tween in the timeline (by default, it's at the end of the timeline). Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the tween inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tween 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * @asparam target Target object (or array of objects) whose properties will be set. 
 * @asparam vars An object defining the value to which each property should be set. For example, to set <code>mc.x</code> to 100 and <code>mc.y</code> to 200, do this: <code>myTimeline.set(mc, {x:100, y:200});</code>
 * @asparam position Controls the placement of the zero-duration tween in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asreturn self (makes chaining easier)
 * @see #to()
 * @see #add()
 * @see #remove()
 * @export
 * @param {Object} target
 * @param {Object} vars
 * @param {*=} position
 * @return {*}
 */
com.greensock.TimelineLite.prototype.set = function(target, vars, position) {
  position = typeof position !== 'undefined' ? position : "+=0";
  position = this._parseTimeOrLabel(position, 0, true);
  vars = com.greensock.TimelineLite._prepVars(vars);
  if (vars.immediateRender == null) {
    vars.immediateRender = (position === this._time && !this._paused);
  }
  return this.add(new com.greensock.TweenLite(target, 0, vars), position);
};


/**
 * Inserts a special callback that pauses playback of the timeline at a
 * particular time or label. This method is more accurate than using a simple callback of your own because 
 * it ensures that even if the virtual playhead had moved slightly beyond the pause position, it'll get moved
 * back to precisely the correct position. 
 * 
 * <p>Remember, the virtual playhead moves to a new position on each tick (frame) of the core timing mechanism, 
 * so it is possible, for example for it to be at 0.99 and then the next render happens at 1.01, so if your
 * callback was at exactly 1 second, the playhead would (in this example) move slightly past where you wanted to
 * pause. Then, if you reverse(), it would run into that callback again and get paused almost immediately. However, 
 * if you use the <code>addPause()</code> method, it will calibrate things so that when the callback is 
 * hit, it'll move the playhead back to <strong>EXACTLY</strong> where it should be. Thus, if you reverse()
 * it won't run into the same callback again.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 
 
 * 
 * <p>The special callback is just a zero-duration tween that utilizes an onComplete, so technically 
 * this callback is just like any other, and it is considered a child of the timeline.</p>
 * 
 * @asparam position Controls the placement of the pause in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the tween 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the tween inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the tween 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asparam callback An optional callback that should be called immediately after the timeline is paused.
 * @asparam params An optional array of parameters to pass the callback. 
 * @asreturn self (makes chaining easier)
 * @see #call()
 * @export
 * @param {*=} position
 * @param {Function=} callback
 * @param {Array=} params
 * @return {*}
 */
com.greensock.TimelineLite.prototype.addPause = function(position, callback, params) {
  position = typeof position !== 'undefined' ? position : "+=0";
  callback = typeof callback !== 'undefined' ? callback : null;
  params = typeof params !== 'undefined' ? params : null;
  return this.call(org.apache.royale.utils.Language.closure(this._pauseCallback, this, '_pauseCallback'), ["{self}", callback, params], position);
};


/** @asprivate *
 * @protected
 * @param {com.greensock.TweenLite} tween
 * @param {Function=} callback
 * @param {Array=} params
 */
com.greensock.TimelineLite.prototype._pauseCallback = function(tween, callback, params) {
  callback = typeof callback !== 'undefined' ? callback : null;
  params = typeof params !== 'undefined' ? params : null;
  this.pause(tween._startTime);
  if (callback != null) {
    callback.apply(null, params);
  }
};


/** @asprivate *
 * @protected
 * @param {Object} vars
 * @return {Object}
 */
com.greensock.TimelineLite._prepVars = function(vars) {
  return (vars._isGSVars) ? vars.vars : vars;
};


/** @asprivate *
 * @protected
 * @param {Object} vars
 * @return {Object}
 */
com.greensock.TimelineLite._copy = function(vars) {
  var /** @type {Object} */ copy = {}, /** @type {string} */ p;
  for (p in vars) {
    copy[p] = vars[p];
  }
  return copy;
};


/**
 * Seamlessly transfers all tweens, timelines, and [optionally] delayed calls from the root 
 * timeline into a new TimelineLite so that you can perform advanced tasks on a seemingly global 
 * basis without affecting tweens/timelines that you create after the export. For example, imagine
 * a game that uses the GreenSock Animation Platform for all of its animations and at some point
 * during the game, you want to slow everything down to a stop (tweening the 
 * <code>timeScale</code>) while at the same time animating a new popup window into place:
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * <p>You could then re-animate things when you're ready by tweening the <code>timeScale</code>
 * back to 1. Or you could use <code>exportRoot()</code> to collect all the animations and 
 * <code>pause()</code> them and then animate the popup screen (or whatever). Then <code>resume()</code>
 * that instance or even <code>reverse()</code>.</p>
 * 
 * <p>You can <code>exportRoot()</code> as many times as you want; all it does is wrap all the 
 * loose tweens/timelines/delayedCalls into a TimelineLite which itself gets placed onto the root, 
 * so if you <code>exportRoot()</code> again, that TimelineLite would get wrapped into another one,
 * etc. Things can be nested as deeply as you want.</p>
 * 
 * <p>Keep in mind, however, that completed tweens/timelines are removed from the root (for automatic 
 * garbage collection), so if you <code>exportRoot()</code> after a tween completes, it won't be 
 * included in the export. The only way around that is to set <code>autoRemoveChildren</code>
 * property of the <code>Animation._rootTimeline</code> and <code>Animation._rootFramesTimeline</code>
 * to <code>false</code>, but that is <strong>NOT</strong> recommended because you'd need to
 * manually <code>kill()</code> your tweens/timelines manually to make them eligible for 
 * garbage collection.</p>
 * 
 * @asparam vars The <code>vars</code> parameter that's passed to the TimelineLite's constructor which allows you to define things like onUpdate, onComplete, etc. The <code>useFrames</code> special property determines which root timeline gets exported. There are two distinct root timelines - one for frames-based animations (<code>useFrames:true</code>) and one for time-based ones. By default, the time-based timeline is exported. 
 * @asparam omitDelayedCalls If <code>true</code> (the default), delayed calls will be left on the root rather than wrapped into the new TimelineLite. That way, if you <code>pause()</code> or alter the <code>timeScale</code>, or <code>reverse()</code>, they won't be affected. However, in some situations it might be very useful to have them included.
 * @asreturn A new TimelineLite instance containing the root tweens/timelines
 * @export
 * @param {Object=} vars
 * @param {boolean=} omitDelayedCalls
 * @return {com.greensock.TimelineLite}
 */
com.greensock.TimelineLite.exportRoot = function(vars, omitDelayedCalls) {
  vars = typeof vars !== 'undefined' ? vars : null;
  omitDelayedCalls = typeof omitDelayedCalls !== 'undefined' ? omitDelayedCalls : true;
  vars = vars || {};
  if (!("smoothChildTiming" in vars)) {
    vars.smoothChildTiming = true;
  }
  var /** @type {com.greensock.TimelineLite} */ tl = new com.greensock.TimelineLite(vars), /** @type {com.greensock.core.SimpleTimeline} */ root = tl._timeline;
  root._remove(tl, true);
  tl._startTime = 0;
  tl._rawPrevTime = tl._time = tl._totalTime = root._time;
  var /** @type {com.greensock.core.Animation} */ tween = root._first, /** @type {com.greensock.core.Animation} */ next;
  while (tween) {
    next = tween._next;
    if (!omitDelayedCalls || !(org.apache.royale.utils.Language.is(tween, com.greensock.TweenLite) && org.apache.royale.utils.Language.as(tween, com.greensock.TweenLite, true).target == tween.vars.onComplete)) {
      tl.add(tween, tween._startTime - tween._delay);
    }
    tween = next;
  }
  root.add(tl, 0);
  return tl;
};


/**
 * @asprivate
 * <strong>[Deprecated in favor of add()]</strong>
 * Inserts a tween, timeline, callback, or label into the timeline at a specific time, frame, 
 * or label. This gives you complete control over the insertion point (<code>append()</code>
 * always puts things at the end). 
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 * 
 * @asparam value The tween, timeline, callback, or label to insert
 * @asparam timeOrLabel The time in seconds (or frames for frames-based timelines) or label at which to insert. For example, <code>myTimeline.insert(myTween, 3)</code> would insert myTween 3-seconds into the timeline, and <code>myTimeline.insert(myTween, "myLabel")</code> would insert it at the "myLabel" label. If you define a label that doesn't exist yet, one is appended to the end of the timeline.
 * @asreturn self (makes chaining easier)
 * @see #add()
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.insert = function(value, timeOrLabel) {
  timeOrLabel = typeof timeOrLabel !== 'undefined' ? timeOrLabel : 0;
  return this.add(value, timeOrLabel || 0);
};


/**
 * Adds a tween, timeline, callback, or label (or an array of them) to the timeline. 
 * 
 * <p>The <code>position</code> parameter gives you complete control over the insertion point.
 * By default, it's at the end of the timeline. Use a number to indicate 
 * an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string
 * with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. 
 * For example, <code>"+=2"</code> would place the object 2 seconds after the end, leaving a 2-second gap. 
 * <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code>
 * to have the object inserted exactly at the label or combine a label and a relative offset like 
 * <code>"myLabel+=2"</code> to insert the object 2 seconds after "myLabel" or <code>"myLabel-=3"</code> 
 * to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it 
 * will <strong>automatically be added to the end of the timeline</strong> before inserting the tween 
 * there which can be quite convenient.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 * 
 * @asparam value The tween, timeline, callback, or label (or array of them) to add
 * @asparam position Controls the placement of the object in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the object 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the object inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the object 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the tween there which can be quite convenient.
 * @asparam align <strong><i>[only relevant when the first parameter, <code>value</code>, is an array]</i></strong> Determines how the tweens/timelines/callbacks/labels in the array that is being added will be aligned in relation to each other before getting inserted. Options are: <code>"sequence"</code> (aligns them one-after-the-other in a sequence), <code>"start"</code> (aligns the start times of all of the objects (ignoring delays)), and <code>"normal"</code> (aligns the start times of all the tweens (honoring delays)). The default is <code>"normal"</code>.
 * @asparam stagger <strong><i>[only relevant when the first parameter, <code>value</code>, is an array]</i></strong> Staggers the inserted objects from the array the is being added by a set amount of time (in seconds) (or in frames for frames-based timelines). For example, if the stagger value is 0.5 and the <code>"align"</code> parameter is set to <code>"start"</code>, the second one will start 0.5 seconds after the first one starts, then 0.5 seconds later the third one will start, etc. If the align property is <code>"sequence"</code>, there would be 0.5 seconds added between each tween. Default is 0.
 * @asreturn self (makes chaining easier)
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.add = function(value, position, align, stagger) {
  position = typeof position !== 'undefined' ? position : "+=0";
  align = typeof align !== 'undefined' ? align : "normal";
  stagger = typeof stagger !== 'undefined' ? stagger : 0;
  if (typeof(position) !== "number") {
    position = this._parseTimeOrLabel(position, 0, true, value);
  }
  if (!org.apache.royale.utils.Language.is(value, com.greensock.core.Animation)) {
    if (org.apache.royale.utils.Language.is(value, Array)) {
      var /** @type {number} */ i = 0, /** @type {number} */ curTime = Number(position), /** @type {number} */ l = Number(value.length), /** @type {*} */ child;
      for (i = 0; i < l; i++) {
        child = value[i];
        if (org.apache.royale.utils.Language.is(child, Array)) {
          child = new com.greensock.TimelineLite({tweens:child});
        }
        this.add(child, curTime);
        if (typeof(child) === "string" || typeof(child) === "function") {
        } else if (align === "sequence") {
          curTime = Number(child._startTime + (child.totalDuration() / child._timeScale));
        } else if (align === "start") {
          child._startTime -= child.delay();
        }
        curTime += stagger;
      }
      return this._uncache(true);
    } else if (typeof(value) === "string") {
      return this.addLabel(String(value), position);
    } else if (typeof(value) === "function") {
      value = com.greensock.TweenLite.delayedCall(0, value);
    } else {
      org.apache.royale.utils.Language.trace("Cannot add " + value + " into the TimelineLite/Max: it is not a tween, timeline, function, or string.");
      return this;
    }
  }
  com.greensock.TimelineLite.superClass_.add.apply(this, [ value, position] );
  if (this._gc || this._time === this._duration)
    if (!this._paused)
      if (this._duration < this.duration()) {
        var /** @type {com.greensock.core.SimpleTimeline} */ tl = this, /** @type {boolean} */ beforeRawTime = (tl.rawTime() > value._startTime);
        while (tl._timeline) {
          if (beforeRawTime && tl._timeline.smoothChildTiming) {
            tl.totalTime(tl._totalTime, true);
          } else if (tl._gc) {
            tl._enabled(true, false);
          }
          tl = tl._timeline;
        }
      }
  return this;
};


/**
 * Removes a tween, timeline, callback, or label (or array of them) from the timeline.
 * 
 * @asparam value The tween, timeline, callback, or label that should be removed from the timeline (or an array of them)
 * @asreturn self (makes chaining easier)
 * @export
 * @param {*} value
 * @return {*}
 */
com.greensock.TimelineLite.prototype.remove = function(value) {
  if (org.apache.royale.utils.Language.is(value, com.greensock.core.Animation)) {
    return this._remove(value, false);
  } else if (org.apache.royale.utils.Language.is(value, Array)) {
    var /** @type {number} */ i = Number(value.length);
    while (--i > -1) {
      this.remove(value[i]);
    }
    return this;
  } else if (typeof(value) == "string") {
    return this.removeLabel(String(value));
  }
  return this.kill(null, value);
};


/** @asprivate *
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype._remove = function(tween, skipDisable) {
  skipDisable = typeof skipDisable !== 'undefined' ? skipDisable : false;
  com.greensock.TimelineLite.superClass_._remove.apply(this, [ tween, skipDisable] );
  if (this._last == null) {
    this._time = this._totalTime = this._duration = this._totalDuration = 0;
  } else if (this._time > this._last._startTime + this._last._totalDuration / this._last._timeScale) {
    this._time = Number(this.duration());
    this._totalTime = this._totalDuration;
  }
  return this;
};


/**
 * @asprivate
 * <strong>[Deprecated in favor of add()]</strong>
 * Appends a tween, timeline, callback, or label to the <strong>end</strong> of the timeline,
 * optionally offsetting its insertion point by a certain amount (to make it overlap with the end of 
 * the timeline or leave a gap before its insertion point). 
 * This makes it easy to build sequences by continuing to append() tweens or timelines. You can
 * chain append() calls together or use the convenience methods like <code>to(), from(), fromTo(),
 * call(), set(), staggerTo(), staggerFrom(),</code> and <code>staggerFromTo()</code> to build
 * sequences with minimal code. 
 * 
 * <p>To insert the tween/timeline/callback/label at a specific position on the timeline 
 * rather than appending it to the end, use the <code>insert()</code> method.</p>
 * 
 * <p>If you define a label (string) as the <code>offsetOrLabel</code> parameter, 
 * the tween/timeline/callback will be inserted wherever that label is, but if the
 * label doesn't exist yet, it will be added to the end of the timeline first and
 * then the tween/timeline/callback will be inserted there. This makes it easier
 * to build things as you go with concise code, adding labels as things get appended.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 * 
 * @asparam value The tween, timeline, callback, or label to append. You can even pass in an array of them.
 * @asparam offsetOrLabel Either a number indicating how many seconds (or frames for frames-based timelines) to offset the insertion point from the end of the timeline (positive values create a gap, negative values create an overlap) or a string indicating the label at which the tween/timeline/callback should be inserted. If you define a label that doesn't exist yet, it will automatically be added to the end of the timeline before the tween/timeline/callback gets appended there. For example, to append a tween 3 seconds after the end of the timeline (leaving a 3-second gap), set the offsetOrLabel to 3. Or to have the tween appended so that it overlaps with the last 2 seconds of the timeline, set the offsetOrLabel to -2. The default is 0 so that the insertion point is exactly at the end of the timeline.
 * @asreturn self (makes chaining easier)
 * @see #add()
 * @see #to()
 * @see #from()
 * @see #fromTo()
 * @see #call()
 * @see #set()
 * @export
 * @param {*} value
 * @param {*=} offsetOrLabel
 * @return {*}
 */
com.greensock.TimelineLite.prototype.append = function(value, offsetOrLabel) {
  offsetOrLabel = typeof offsetOrLabel !== 'undefined' ? offsetOrLabel : 0;
  return this.add(value, this._parseTimeOrLabel(null, offsetOrLabel, true, value));
};


/**
 * @asprivate
 * <strong>[Deprecated in favor of add()]</strong>
 * Inserts multiple tweens/timelines/callbacks/labels into the timeline at once, optionally aligning them 
 * (as a sequence for example) and/or staggering the timing. You can use the <code>insert()</code> method
 * instead if you are not defining a <code>stagger</code> or <code>align</code> (either way works).
 *  
 * @asparam tweens An array containing the tweens, timelines, callbacks, or labels that should be inserted  
 * @asparam timeOrLabel Time in seconds (or frame if the timeline is frames-based) or label that serves as the insertion point. For example, the number 2 would insert the first object in the array at 2-seconds into the timeline, or "myLabel" would ihsert them wherever "myLabel" is.
 * @asparam align Determines how the tweens/timelines/callbacks/labels will be aligned in relation to each other before getting inserted. Options are: <code>"sequence"</code> (aligns them one-after-the-other in a sequence), <code>"start"</code> (aligns the start times of all of the objects (ignoring delays)), and <code>"normal"</code> (aligns the start times of all the tweens (honoring delays)). The default is <code>"normal"</code>.
 * @asparam stagger Staggers the tweens by a set amount of time (in seconds) (or in frames for frames-based timelines). For example, if the stagger value is 0.5 and the <code>"align"</code> parameter is set to <code>"start"</code>, the second one will start 0.5 seconds after the first one starts, then 0.5 seconds later the third one will start, etc. If the align property is <code>"sequence"</code>, there would be 0.5 seconds added between each tween. Default is 0.
 * @asreturn self (makes chaining easier)
 * @see #add()
 * @see #staggerTo()
 * @see #staggerFrom()
 * @see #staggerFromTo()
 * @export
 * @param {Array} tweens
 * @param {*=} timeOrLabel
 * @param {string=} align
 * @param {number=} stagger
 * @return {*}
 */
com.greensock.TimelineLite.prototype.insertMultiple = function(tweens, timeOrLabel, align, stagger) {
  timeOrLabel = typeof timeOrLabel !== 'undefined' ? timeOrLabel : 0;
  align = typeof align !== 'undefined' ? align : "normal";
  stagger = typeof stagger !== 'undefined' ? stagger : 0;
  return this.add(tweens, timeOrLabel || 0, align, stagger);
};


/**
 * @asprivate
 * <strong>[Deprecated in favor of add()]</strong>
 * Appends multiple tweens/timelines/callbacks/labels to the end of the timeline at once, optionally 
 * offsetting the insertion point by a certain amount, aligning them (as a sequence for example), and/or 
 * staggering their relative timing. You can use the <code>add()</code> method 
 * instead if you are not defining a <code>stagger</code> or <code>align</code> (either way works).
 * Check out the <code>staggerTo()</code> method for an even easier way to create and append
 * a sequence of evenly-spaced tweens.
 *  
 * @asparam tweens An array containing the tweens, timelines, callbacks, and/or labels that should be appended  
 * @asparam offsetOrLabel Either a number indicating how many seconds (or frames for frames-based timelines) to offset the insertion point from the end of the timeline (positive values create a gap, negative values create an overlap) or a string indicating the label at which the tween should be inserted. If you define a label that doesn't exist yet, it will automatically be added to the end of the timeline before the tweens/timelines/callbacks gets appended there. For example, to begin appending the tweens 3 seconds after the end of the timeline (leaving a 3-second gap), set the offsetOrLabel to 3. Or to begin appending the tweens/timelines/callbacks so that they overlap with the last 2 seconds of the timeline, set the offsetOrLabel to -2. The default is 0 so that the insertion point is exactly at the end of the timeline.
 * @asparam align Determines how the objects will be aligned in relation to each other before getting appended. Options are: TweenAlign.SEQUENCE (aligns the tweens one-after-the-other in a sequence), TweenAlign.START (aligns the start times of all of the tweens (ignores delays)), and TweenAlign.NORMAL (aligns the start times of all the tweens (honors delays)). The default is NORMAL.
 * @asparam stagger Staggers the tweens by a set amount of time (in seconds) (or in frames for frames-based timelines). For example, if the stagger value is 0.5 and the <code>"align"</code> parameter is set to <code>"start"</code>, the second one will start 0.5 seconds after the first one starts, then 0.5 seconds later the third one will start, etc. If the align property is <code>"sequence"</code>, there would be 0.5 seconds added between each tween. Default is 0.
 * @asreturn The array of tweens that were appended
 * @export
 * @param {Array} tweens
 * @param {*=} offsetOrLabel
 * @param {string=} align
 * @param {number=} stagger
 * @return {*}
 */
com.greensock.TimelineLite.prototype.appendMultiple = function(tweens, offsetOrLabel, align, stagger) {
  offsetOrLabel = typeof offsetOrLabel !== 'undefined' ? offsetOrLabel : 0;
  align = typeof align !== 'undefined' ? align : "normal";
  stagger = typeof stagger !== 'undefined' ? stagger : 0;
  return this.add(tweens, this._parseTimeOrLabel(null, offsetOrLabel, true, tweens), align, stagger);
};


/**
 * Adds a label to the timeline, making it easy to mark important positions/times. You can then
 * reference that label in other methods, like <code>seek("myLabel")</code> or <code>add(myTween, "myLabel")</code>
 * or <code>reverse("myLabel")</code>. You could also use the <code>add()</code> method to insert a label.
 * 
 * @asparam label The name of the label
 * @asparam position Controls the placement of the label in the timeline (by default, it's the end of the timeline, like "+=0"). Use a number to indicate an absolute time in terms of seconds (or frames for frames-based timelines), or you can use a string with a "+=" or "-=" prefix to offset the insertion point relative to the END of the timeline. For example, <code>"+=2"</code> would place the label 2 seconds after the end, leaving a 2-second gap. <code>"-=2"</code> would create a 2-second overlap. You may also use a label like <code>"myLabel"</code> to have the label inserted exactly at the label or combine a label and a relative offset like <code>"myLabel+=2"</code> to insert the label 2 seconds after "myLabel" or <code>"myLabel-=3"</code> to insert it 3 seconds before "myLabel". If you define a label that doesn't exist yet, it will <strong>automatically be added to the end of the timeline</strong> before inserting the label there which can be quite convenient.
 * @export
 * @param {string} label
 * @param {*=} position
 * @return {*}
 */
com.greensock.TimelineLite.prototype.addLabel = function(label, position) {
  position = typeof position !== 'undefined' ? position : "+=0";
  this._labels[label] = this._parseTimeOrLabel(position);
  return this;
};


/**
 * 
 * Removes a label from the timeline and returns the time of that label. You could 
 * also use the <code>remove()</code> method to accomplish the same task.
 * 
 * @asparam label The name of the label to remove
 * @asreturn Time associated with the label that was removed
 * @export
 * @param {string} label
 * @return {*}
 */
com.greensock.TimelineLite.prototype.removeLabel = function(label) {
  delete this._labels[label];
  return this;
};


/**
 * Returns the time associated with a particular label. If the label isn't found, -1 is returned.
 * 
 * @asparam label Label name
 * @asreturn Time associated with the label (or -1 if there is no such label)
 * @export
 * @param {string} label
 * @return {number}
 */
com.greensock.TimelineLite.prototype.getLabelTime = function(label) {
  return (label in this._labels) ? Number(this._labels[label]) : -1;
};


/** @asprivate *
 * @protected
 * @param {*} timeOrLabel
 * @param {*=} offsetOrLabel
 * @param {boolean=} appendIfAbsent
 * @param {Object=} ignore
 * @return {number}
 */
com.greensock.TimelineLite.prototype._parseTimeOrLabel = function(timeOrLabel, offsetOrLabel, appendIfAbsent, ignore) {
  offsetOrLabel = typeof offsetOrLabel !== 'undefined' ? offsetOrLabel : 0;
  appendIfAbsent = typeof appendIfAbsent !== 'undefined' ? appendIfAbsent : false;
  ignore = typeof ignore !== 'undefined' ? ignore : null;
  var /** @type {number} */ i = 0;
  if (org.apache.royale.utils.Language.is(ignore, com.greensock.core.Animation) && ignore.timeline === this) {
    this.remove(ignore);
  } else if (org.apache.royale.utils.Language.is(ignore, Array)) {
    i = Number(ignore.length);
    while (--i > -1) {
      if (org.apache.royale.utils.Language.is(ignore[i], com.greensock.core.Animation) && ignore[i].timeline === this) {
        this.remove(ignore[i]);
      }
    }
  }
  if (typeof(offsetOrLabel) === "string") {
    return this._parseTimeOrLabel(offsetOrLabel, (appendIfAbsent && typeof(timeOrLabel) === "number" && !(offsetOrLabel in this._labels)) ? timeOrLabel - this.duration() : 0, appendIfAbsent);
  }
  offsetOrLabel = offsetOrLabel || 0;
  if (typeof(timeOrLabel) === "string" && (isNaN(timeOrLabel) || (timeOrLabel in this._labels))) {
    i = Number(timeOrLabel.indexOf("="));
    if (i === -1) {
      if (!(timeOrLabel in this._labels)) {
        return appendIfAbsent ? (this._labels[timeOrLabel] = this.duration() + offsetOrLabel) : offsetOrLabel;
      }
      return this._labels[timeOrLabel] + offsetOrLabel;
    }
    offsetOrLabel = parseInt(timeOrLabel.charAt(i - 1) + "1", 10) * Number(timeOrLabel.substr(i + 1));
    timeOrLabel = (i > 1) ? this._parseTimeOrLabel(timeOrLabel.substr(0, i - 1), 0, appendIfAbsent) : this.duration();
  } else if (timeOrLabel == null) {
    timeOrLabel = this.duration();
  }
  return Number(timeOrLabel) + offsetOrLabel;
};


/**
 * Jumps to a specific time (or label) without affecting whether or not the instance 
 * is paused or reversed.
 * 
 * <p>If there are any events/callbacks inbetween where the playhead was and the new time, 
 * they will not be triggered because by default <code>suppressEvents</code> (the 2nd parameter) 
 * is <code>true</code>. Think of it like picking the needle up on a record player and moving it 
 * to a new position before placing it back on the record. If, however, you do not want the 
 * events/callbacks suppressed during that initial move, simply set the <code>suppressEvents</code> 
 * parameter to <code>false</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 * 
 * @asparam position The position to go to, described in any of the following ways: a numeric value indicates an absolute position, like 3 would be exactly 3 seconds from the beginning of the timeline. A string value can be either a label (i.e. "myLabel") or a relative value using the "+=" or "-=" prefixes like "-=2" (2 seconds before the end of the timeline) or a combination like "myLabel+=2" to indicate 2 seconds after "myLabel".
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>time</code> parameter.
 * @asreturn self (makes chaining easier)
 * @see #time()
 * @see #totalTime()
 * @see #play()
 * @see #reverse()
 * @see #pause()
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.seek = function(position, suppressEvents) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  return this.totalTime((typeof(position) === "number") ? Number(position) : this._parseTimeOrLabel(position), suppressEvents);
};


/** [deprecated] Pauses the timeline (used for consistency with Flash's MovieClip.stop() functionality, but essentially accomplishes the same thing as <code>pause()</code> without the parameter) @asreturn self (makes chaining easier) *
 * @export
 * @return {*}
 */
com.greensock.TimelineLite.prototype.stop = function() {
  return this.paused(true);
};


/**
 * @asprivate
 * [deprecated]
 * Skips to a particular time, frame, or label and plays the timeline forward from there (unpausing it)
 * 
 * @asparam position The position to go to, described in any of the following ways: a numeric value indicates an absolute position, like 3 would be exactly 3 seconds from the beginning of the timeline. A string value can be either a label (i.e. "myLabel") or a relative value using the "+=" or "-=" prefixes like "-=2" (2 seconds before the end of the timeline) or a combination like "myLabel+=2" to indicate 2 seconds after "myLabel".
 * @asparam suppressEvents If true, no events or callbacks will be triggered as the "virtual playhead" moves to the new position (onComplete, onUpdate, onReverseComplete, etc. of this timeline and any of its child tweens/timelines won't be triggered, nor will any of the associated events be dispatched) 
 * @export
 * @param {*} position
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.TimelineLite.prototype.gotoAndPlay = function(position, suppressEvents) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  return this.play(position, suppressEvents);
};


/**
 * @asprivate
 * [deprecated]
 * Skips to a particular time, frame, or label and stops the timeline (pausing it)
 * 
 * @asparam position The position to go to, described in any of the following ways: a numeric value indicates an absolute position, like 3 would be exactly 3 seconds from the beginning of the timeline. A string value can be either a label (i.e. "myLabel") or a relative value using the "+=" or "-=" prefixes like "-=2" (2 seconds before the end of the timeline) or a combination like "myLabel+=2" to indicate 2 seconds after "myLabel".
 * @asparam suppressEvents If true, no events or callbacks will be triggered as the "virtual playhead" moves to the new position (onComplete, onUpdate, onReverseComplete, etc. of this timeline and any of its child tweens/timelines won't be triggered, nor will any of the associated events be dispatched) 
 * @export
 * @param {*} position
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.TimelineLite.prototype.gotoAndStop = function(position, suppressEvents) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  return this.pause(position, suppressEvents);
};


/**
 * @asprivate
 * Renders all tweens and sub-timelines in the state they'd be at a particular time (or frame for frames-based timelines). 
 * 
 * @asparam time time in seconds (or frames for frames-based timelines) that should be rendered. 
 * @asparam suppressEvents If true, no events or callbacks will be triggered for this render (like onComplete, onUpdate, onReverseComplete, etc.)
 * @asparam force Normally the tween will skip rendering if the time matches the cachedTotalTime (to improve performance), but if force is true, it forces a render. This is primarily used internally for tweens with durations of zero in TimelineLite/Max instances.
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.render = function(time, suppressEvents, force) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  force = typeof force !== 'undefined' ? force : false;
  if (this._gc) {
    this._enabled(true, false);
  }
  var /** @type {number} */ totalDur = Number((!this._dirty) ? this._totalDuration : this.totalDuration()), /** @type {number} */ prevTime = this._time, /** @type {number} */ prevStart = this._startTime, /** @type {number} */ prevTimeScale = this._timeScale, /** @type {boolean} */ prevPaused = this._paused, /** @type {com.greensock.core.Animation} */ tween, /** @type {boolean} */ isComplete, /** @type {com.greensock.core.Animation} */ next, /** @type {string} */ callback, /** @type {boolean} */ internalForce;
  if (time >= totalDur) {
    this._totalTime = this._time = totalDur;
    if (!this._reversed)
      if (!this._hasPausedChild()) {
        isComplete = true;
        callback = "onComplete";
        if (this._duration === 0)
          if (time === 0 || this._rawPrevTime < 0 || this._rawPrevTime === com.greensock.core.Animation._tinyNum)
            if (this._rawPrevTime !== time && this._first != null) {
              internalForce = true;
              if (this._rawPrevTime > com.greensock.core.Animation._tinyNum) {
                callback = "onReverseComplete";
              }
            }
      }
    this._rawPrevTime = (this._duration !== 0 || !suppressEvents || time !== 0 || this._rawPrevTime === time) ? time : com.greensock.core.Animation._tinyNum;
    time = totalDur + 0.0001;
  } else if (time < 0.0000001) {
    this._totalTime = this._time = 0;
    if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime !== com.greensock.core.Animation._tinyNum && (this._rawPrevTime > 0 || (time < 0 && this._rawPrevTime >= 0)))) {
      callback = "onReverseComplete";
      isComplete = this._reversed;
    }
    if (time < 0) {
      this._active = false;
      if (this._rawPrevTime >= 0 && this._first != null) {
        internalForce = true;
      }
      this._rawPrevTime = time;
    } else {
      this._rawPrevTime = (this._duration || !suppressEvents || time !== 0 || this._rawPrevTime === time) ? time : com.greensock.core.Animation._tinyNum;
      time = 0;
      if (!this._initted) {
        internalForce = true;
      }
    }
  } else {
    this._totalTime = this._time = this._rawPrevTime = time;
  }
  if ((this._time == prevTime || !this._first) && !force && !internalForce) {
    return;
  } else if (!this._initted) {
    this._initted = true;
  }
  if (!this._active)
    if (!this._paused && this._time !== prevTime && time > 0) {
      this._active = true;
    }
  if (prevTime == 0)
    if (this.vars.onStart)
      if (this._time != 0)
        if (!suppressEvents) {
          this.vars.onStart.apply(null, this.vars.onStartParams);
        }
  if (this._time >= prevTime) {
    tween = this._first;
    while (tween) {
      next = tween._next;
      if (this._paused && !prevPaused) {
        break;
      } else if (tween._active || (tween._startTime <= this._time && !tween._paused && !tween._gc)) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
        }
      }
      tween = next;
    }
  } else {
    tween = this._last;
    while (tween) {
      next = tween._prev;
      if (this._paused && !prevPaused) {
        break;
      } else if (tween._active || (tween._startTime <= prevTime && !tween._paused && !tween._gc)) {
        if (!tween._reversed) {
          tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
        } else {
          tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
        }
      }
      tween = next;
    }
  }
  if (this._onUpdate != null)
    if (!suppressEvents) {
      this._onUpdate.apply(null, this.vars.onUpdateParams);
    }
  if (callback)
    if (!this._gc)
      if (prevStart == this._startTime || prevTimeScale != this._timeScale)
        if (this._time == 0 || totalDur >= this.totalDuration()) {
          if (isComplete) {
            if (this._timeline.autoRemoveChildren) {
              this._enabled(false, false);
            }
            this._active = false;
          }
          if (!suppressEvents)
            if (this.vars[callback]) {
              this.vars[callback].apply(null, this.vars[callback + "Params"]);
            }
        }
};


/**
 * @asprivate
 * Checks the timeline to see if it has any paused children (tweens/timelines). 
 * 
 * @asreturn Indicates whether or not the timeline contains any paused children
 * @export
 * @return {boolean}
 */
com.greensock.TimelineLite.prototype._hasPausedChild = function() {
  var /** @type {com.greensock.core.Animation} */ tween = this._first;
  while (tween) {
    if (tween._paused || (org.apache.royale.utils.Language.is(tween, com.greensock.TimelineLite) && org.apache.royale.utils.Language.as(tween, com.greensock.TimelineLite, true)._hasPausedChild())) {
      return true;
    }
    tween = tween._next;
  }
  return false;
};


/**
 * Returns an array containing all the tweens and/or timelines nested in this timeline.
 * Callbacks (delayed calls) are considered zero-duration tweens.
 *  
 * @asparam nested Determines whether or not tweens and/or timelines that are inside nested timelines should be returned. If you only want the "top level" tweens/timelines, set this to <code>false</code>.
 * @asparam tweens Determines whether or not tweens (TweenLite and TweenMax instances) should be included in the results
 * @asparam timelines Determines whether or not timelines (TimelineLite and TimelineMax instances) should be included in the results
 * @asparam ignoreBeforeTime All children with start times that are less than this value will be ignored.
 * @asreturn an Array containing the child tweens/timelines.
 * @export
 * @param {boolean=} nested
 * @param {boolean=} tweens
 * @param {boolean=} timelines
 * @param {number=} ignoreBeforeTime
 * @return {Array}
 */
com.greensock.TimelineLite.prototype.getChildren = function(nested, tweens, timelines, ignoreBeforeTime) {
  nested = typeof nested !== 'undefined' ? nested : true;
  tweens = typeof tweens !== 'undefined' ? tweens : true;
  timelines = typeof timelines !== 'undefined' ? timelines : true;
  ignoreBeforeTime = typeof ignoreBeforeTime !== 'undefined' ? ignoreBeforeTime : -9999999999;
  var /** @type {Array} */ a = [], /** @type {com.greensock.core.Animation} */ tween = this._first, /** @type {number} */ cnt = 0;
  while (tween) {
    if (tween._startTime < ignoreBeforeTime) {
    } else if (org.apache.royale.utils.Language.is(tween, com.greensock.TweenLite)) {
      if (tweens) {
        a[cnt++] = tween;
      }
    } else {
      if (timelines) {
        a[cnt++] = tween;
      }
      if (nested) {
        a = a.concat(org.apache.royale.utils.Language.as(tween, com.greensock.TimelineLite, true).getChildren(true, tweens, timelines));
        cnt = a.length;
      }
    }
    tween = tween._next;
  }
  return a;
};


/**
 * Returns the tweens of a particular object that are inside this timeline.
 * 
 * @asparam target The target object of the tweens
 * @asparam nested Determines whether or not tweens that are inside nested timelines should be returned. If you only want the "top level" tweens/timelines, set this to false.
 * @asreturn an Array of TweenLite and/or TweenMax instances
 * @export
 * @param {Object} target
 * @param {boolean=} nested
 * @return {Array}
 */
com.greensock.TimelineLite.prototype.getTweensOf = function(target, nested) {
  nested = typeof nested !== 'undefined' ? nested : true;
  var /** @type {boolean} */ disabled = this._gc, /** @type {Array} */ a = [], /** @type {number} */ cnt = 0, /** @type {Array} */ tweens, /** @type {number} */ i = 0;
  if (disabled) {
    this._enabled(true, true);
  }
  tweens = com.greensock.TweenLite.getTweensOf(target);
  i = tweens.length;
  while (--i > -1) {
    if (tweens[i].timeline === this || (nested && this._contains(tweens[i]))) {
      a[cnt++] = tweens[i];
    }
  }
  if (disabled) {
    this._enabled(false, true);
  }
  return a;
};


/** @asprivate *
 * @private
 * @param {com.greensock.core.Animation} tween
 * @return {boolean}
 */
com.greensock.TimelineLite.prototype._contains = function(tween) {
  var /** @type {com.greensock.core.SimpleTimeline} */ tl = tween.timeline;
  while (tl) {
    if (tl == this) {
      return true;
    }
    tl = tl.timeline;
  }
  return false;
};


/**
 * Shifts the startTime of the timeline's children by a certain amount and optionally adjusts labels too. 
 * This can be useful when you want to prepend children or splice them into a certain spot, moving existing 
 * ones back to make room for the new ones.
 * 
 * @asparam amount Number of seconds (or frames for frames-based timelines) to move each child.
 * @asparam adjustLabels If <code>true</code>, the timing of all labels will be adjusted as well.
 * @asparam ignoreBeforeTime All children that begin at or after the <code>startAtTime</code> will be affected by the shift (the default is 0, causing all children to be affected). This provides an easy way to splice children into a certain spot on the timeline, pushing only the children after that point back to make room.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {number} amount
 * @param {boolean=} adjustLabels
 * @param {number=} ignoreBeforeTime
 * @return {*}
 */
com.greensock.TimelineLite.prototype.shiftChildren = function(amount, adjustLabels, ignoreBeforeTime) {
  adjustLabels = typeof adjustLabels !== 'undefined' ? adjustLabels : false;
  ignoreBeforeTime = typeof ignoreBeforeTime !== 'undefined' ? ignoreBeforeTime : 0;
  var /** @type {com.greensock.core.Animation} */ tween = this._first;
  while (tween) {
    if (tween._startTime >= ignoreBeforeTime) {
      tween._startTime += amount;
    }
    tween = tween._next;
  }
  if (adjustLabels) {
    for (var /** @type {string} */ p in this._labels) {
      if (this._labels[p] >= ignoreBeforeTime) {
        this._labels[p] += amount;
      }
    }
  }
  this._uncache(true);
  return this;
};


/** @asprivate *
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype._kill = function(vars, target) {
  vars = typeof vars !== 'undefined' ? vars : null;
  target = typeof target !== 'undefined' ? target : null;
  if (vars == null)
    if (target == null) {
      return this._enabled(false, false);
    }
  var /** @type {Array} */ tweens = (target == null) ? this.getChildren(true, true, false) : this.getTweensOf(target), /** @type {number} */ i = tweens.length, /** @type {boolean} */ changed = false;
  while (--i > -1) {
    if (tweens[i]._kill(vars, target)) {
      changed = true;
    }
  }
  return changed;
};


/**
 * Empties the timeline of all tweens, timelines, and callbacks (and optionally labels too).
 * Event callbacks (like onComplete, onUpdate, onStart, etc.) are not removed. If you need 
 * to remove event callbacks, use the <code>eventCallback()</code> method and set them to null
 * like <code>myTimeline.eventCallback("onComplete", null);</code>
 * 
 * @asparam labels If <code>true</code> (the default), labels will be cleared too.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {boolean=} labels
 * @return {*}
 */
com.greensock.TimelineLite.prototype.clear = function(labels) {
  labels = typeof labels !== 'undefined' ? labels : true;
  var /** @type {Array} */ tweens = this.getChildren(false, true, true), /** @type {number} */ i = tweens.length;
  this._time = this._totalTime = 0;
  while (--i > -1) {
    tweens[i]._enabled(false, false);
  }
  if (labels) {
    this._labels = {};
  }
  return this._uncache(true);
};


/** @inheritDoc *
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.invalidate = function() {
  var /** @type {com.greensock.core.Animation} */ tween = this._first;
  while (tween) {
    tween.invalidate();
    tween = tween._next;
  }
  return this;
};


/** @asprivate *
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype._enabled = function(enabled, ignoreTimeline) {
  ignoreTimeline = typeof ignoreTimeline !== 'undefined' ? ignoreTimeline : false;
  if (enabled == this._gc) {
    var /** @type {com.greensock.core.Animation} */ tween = this._first;
    while (tween) {
      tween._enabled(enabled, true);
      tween = tween._next;
    }
  }
  return com.greensock.TimelineLite.superClass_._enabled.apply(this, [ enabled, ignoreTimeline] );
};


/**
 * Gets the timeline's <code>duration</code> or, if used as a setter, adjusts the timeline's 
 * <code>timeScale</code> to fit it within the specified duration. <code>duration()</code> is identical
 * to <code>totalDuration()</code> except for TimelineMax instances that have a non-zero <code>repeat</code> 
 * in which case <code>totalDuration</code> includes repeats and repeatDelays whereas <code>duration</code> doesn't. 
 * For example, if a TimelineMax instance has a <code>duration</code> of 2 and a <code>repeat</code> of 3, 
 * its <code>totalDuration</code> would be 8 (one standard play plus 3 repeats equals 4 total cycles). 
 * 
 * <p>Due to the fact that a timeline's <code>duration</code> is dictated by its contents, 
 * using this method as a setter will simply cause the <code>timeScale</code> to be adjusted
 * to fit the current contents into the specified <code>duration</code>, but the <code>duration</code> 
 * value itself will remain unchanged. For example, if there are 20-seconds worth of tweens in the timeline 
 * and you do <code>myTimeline.duration(10)</code>, the <code>timeScale</code> would be changed to 2. 
 * If you checked the <code>duration</code> again immediately after that, it would still return 20 because 
 * technically that is how long all the child tweens/timelines are but upon playback the speed would 
 * be doubled because of the <code>timeScale</code>.</p>
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.duration(2).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #totalDuration()
 * @see #timeScale()
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.duration = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  if (!arguments.length) {
    if (this._dirty) {
      this.totalDuration();
    }
    return this._duration;
  }
  if (this.duration() !== 0)
    if (value !== 0) {
      this.timeScale(this._duration / value);
    }
  return this;
};


/**
 * Gets the timeline's <strong>total</strong> duration or, if used as a setter, adjusts the timeline's 
 * <code>timeScale</code> to fit it within the specified duration. For example, if a TimelineMax instance has 
 * a <code>duration</code> of 2 and a <code>repeat</code> of 3, its <code>totalDuration</code> 
 * would be 8 (one standard play plus 3 repeats equals 4 total cycles). 
 * 
 * <p>Due to the fact that a timeline's <code>totalDuration</code> is dictated by its contents, 
 * using this method as a setter will simply cause the <code>timeScale</code> to be adjusted
 * to fit the current contents into the specified <code>totalDuration</code>. For example, 
 * if there are 20-seconds worth of tweens in the timeline and you do <code>myTimeline.totalDuration(10)</code>,
 * the <code>timeScale</code> would be changed to 2. If you checked the <code>totalDuration</code> again
 * immediately after that, it would still return 20 because technically that is how long all the 
 * child tweens/timelines are but upon playback the speed would be doubled because of the 
 * <code>timeScale</code>.</p>
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.totalDuration(2).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #timeScale()
 * @see #duration()
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.totalDuration = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  if (!arguments.length) {
    if (this._dirty) {
      var /** @type {number} */ max = 0, /** @type {com.greensock.core.Animation} */ tween = this._last, /** @type {number} */ prevStart = Infinity, /** @type {com.greensock.core.Animation} */ prev, /** @type {number} */ end;
      while (tween) {
        prev = tween._prev;
        if (tween._dirty) {
          tween.totalDuration();
        }
        if (tween._startTime > prevStart && this._sortChildren && !tween._paused) {
          this.add(tween, tween._startTime - tween._delay);
        } else {
          prevStart = tween._startTime;
        }
        if (tween._startTime < 0 && !tween._paused) {
          max -= tween._startTime;
          if (this._timeline.smoothChildTiming) {
            this._startTime += tween._startTime / this._timeScale;
          }
          this.shiftChildren(-tween._startTime, false, -9999999999);
          prevStart = 0;
        }
        end = tween._startTime + (tween._totalDuration / tween._timeScale);
        if (end > max) {
          max = end;
        }
        tween = prev;
      }
      this._duration = this._totalDuration = max;
      this._dirty = false;
    }
    return this._totalDuration;
  }
  if (this.totalDuration() != 0)
    if (value != 0) {
      this.timeScale(this._totalDuration / value);
    }
  return this;
};


/** 
 * [READ-ONLY] If <code>true</code>, the timeline's timing mode is frames-based instead of
 * seconds. This can only be set to <code>true</code> by passing <code>useFrames:true</code> in 
 * the vars parameter of the constructor, or by nesting this timeline in another whose 
 * timing mode is frames-based. An animation's timing mode is always determined by its parent timeline).
 * @export
 * @return {boolean}
 */
com.greensock.TimelineLite.prototype.usesFrames = function() {
  var /** @type {com.greensock.core.SimpleTimeline} */ tl = this._timeline;
  while (tl._timeline) {
    tl = tl._timeline;
  }
  return (tl == com.greensock.core.Animation._rootFramesTimeline);
};


/**
 * @asprivate
 * Reports the totalTime of the timeline without capping the number at the <code>totalDuration</code> (max) 
 * and zero (minimum) which can be useful when unpausing tweens/timelines. Imagine a case where a paused 
 * tween is in a timeline that has already reached the end, but then the tween gets unpaused - it needs a 
 * way to place itself accurately in time AFTER what was previously the timeline's end time.
 * 
 * @asreturn The <code>totalTime</code> of the timeline without capping the number at the <code>totalDuration</code> (max) and zero (minimum)
 * @export
 * @override
 */
com.greensock.TimelineLite.prototype.rawTime = function() {
  return this._paused ? this._totalTime : (this._timeline.rawTime() - this._startTime) * this._timeScale;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
com.greensock.TimelineLite.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'TimelineLite', qName: 'com.greensock.TimelineLite', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
com.greensock.TimelineLite.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        'TimelineLite': { type: '', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: true } ]; }},
        'to': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: '*', optional: true } ]; }},
        'from': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: '*', optional: true } ]; }},
        'fromTo': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: 'Object', optional: false },{ index: 5, type: '*', optional: true } ]; }},
        'staggerTo': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Array', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: 'Number', optional: false },{ index: 5, type: '*', optional: true },{ index: 6, type: 'Function', optional: true },{ index: 7, type: 'Array', optional: true } ]; }},
        'staggerFrom': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Array', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: 'Number', optional: true },{ index: 5, type: '*', optional: true },{ index: 6, type: 'Function', optional: true },{ index: 7, type: 'Array', optional: true } ]; }},
        'staggerFromTo': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Array', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: 'Object', optional: false },{ index: 5, type: 'Number', optional: true },{ index: 6, type: '*', optional: true },{ index: 7, type: 'Function', optional: true },{ index: 8, type: 'Array', optional: true } ]; }},
        'call': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Function', optional: false },{ index: 2, type: 'Array', optional: true },{ index: 3, type: '*', optional: true } ]; }},
        'set': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Object', optional: false },{ index: 3, type: '*', optional: true } ]; }},
        'addPause': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: true },{ index: 2, type: 'Function', optional: true },{ index: 3, type: 'Array', optional: true } ]; }},
        '|exportRoot': { type: 'com.greensock.TimelineLite', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'insert': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'add': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: '*', optional: true },{ index: 3, type: 'String', optional: true },{ index: 4, type: 'Number', optional: true } ]; }},
        'remove': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false } ]; }},
        '_remove': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'com.greensock.core.Animation', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'append': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'insertMultiple': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Array', optional: false },{ index: 2, type: '*', optional: true },{ index: 3, type: 'String', optional: true },{ index: 4, type: 'Number', optional: true } ]; }},
        'appendMultiple': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Array', optional: false },{ index: 2, type: '*', optional: true },{ index: 3, type: 'String', optional: true },{ index: 4, type: 'Number', optional: true } ]; }},
        'addLabel': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'removeLabel': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'getLabelTime': { type: 'Number', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'String', optional: false } ]; }},
        'seek': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'stop': { type: '*', declaredBy: 'com.greensock.TimelineLite'},
        'gotoAndPlay': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'gotoAndStop': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'render': { type: 'void', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Boolean', optional: true } ]; }},
        '_hasPausedChild': { type: 'Boolean', declaredBy: 'com.greensock.TimelineLite'},
        'getChildren': { type: 'Array', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Boolean', optional: true },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Boolean', optional: true },{ index: 4, type: 'Number', optional: true } ]; }},
        'getTweensOf': { type: 'Array', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'shiftChildren': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Number', optional: true } ]; }},
        '_kill': { type: 'Boolean', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Object', optional: true },{ index: 2, type: 'Object', optional: true } ]; }},
        'clear': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Boolean', optional: true } ]; }},
        'invalidate': { type: '*', declaredBy: 'com.greensock.TimelineLite'},
        '_enabled': { type: 'Boolean', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Boolean', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'duration': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'totalDuration': { type: '*', declaredBy: 'com.greensock.TimelineLite', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'usesFrames': { type: 'Boolean', declaredBy: 'com.greensock.TimelineLite'},
        'rawTime': { type: 'Number', declaredBy: 'com.greensock.TimelineLite'}
      };
    }
  };
};
