/**
 * Generated by Apache Royale Compiler from com\greensock\TweenLite.as
 * com.greensock.TweenLite
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('com.greensock.TweenLite');
/* Royale Dependency List: com.greensock.core.PropTween,com.greensock.core.SimpleTimeline,flash.display.Shape,flash.events.Event,org.apache.royale.utils.Language,XML*/
/* Royale Static Dependency List: com.greensock.easing.Ease,com.greensock.core.Animation,flash.utils.Dictionary*/

goog.require('com.greensock.core.Animation');
goog.require('com.greensock.easing.Ease');
goog.require('flash.utils.Dictionary');



/**
 * Constructor
 *  
 * @asparam target Target object (or array of objects) whose properties this tween affects 
 * @asparam duration Duration in seconds (or frames if <code>useFrames:true</code> is set in the <code>vars</code> parameter)
 * @asparam vars An object defining the end value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> to 100 and <code>mc.y</code> to 200 and then call <code>myFunction</code>, do this: <code>new TweenLite(mc, 1, {x:100, y:200, onComplete:myFunction})</code>.
 * @constructor
 * @extends {com.greensock.core.Animation}
 * @param {Object} target
 * @param {number} duration
 * @param {Object} vars
 */
com.greensock.TweenLite = function(target, duration, vars) {
  com.greensock.TweenLite.base(this, 'constructor', duration, vars);
  if (target == null) {
    throw new Error("Cannot tween a null object. Duration: " + duration + ", data: " + this.data);
  }
  if (!com.greensock.TweenLite._overwriteLookup) {
    com.greensock.TweenLite._overwriteLookup = {none:0, all:1, auto:2, concurrent:3, allOnStart:4, preexisting:5, "true":1, "false":0};
    com.greensock.TweenLite.ticker.addEventListener("enterFrame", com.greensock.TweenLite._dumpGarbage, false, -1, true);
  }
  this.ratio = 0;
  this.target = target;
  this._ease = com.greensock.TweenLite.defaultEase;
  this._overwrite = Number((!("overwrite" in this.vars)) ? com.greensock.TweenLite._overwriteLookup[com.greensock.TweenLite.defaultOverwrite] : (typeof((this.vars.overwrite)) === "number") ? this.vars.overwrite >> 0 : com.greensock.TweenLite._overwriteLookup[this.vars.overwrite]);
  if (org.apache.royale.utils.Language.is(this.target, Array) && typeof(this.target[0]) === "object") {
    this._targets = this.target.concat();
    this._propLookup = [];
    this._siblings = [];
    var /** @type {number} */ i = this._targets.length;
    while (--i > -1) {
      this._siblings[i] = com.greensock.TweenLite._register(this._targets[i], this, false);
      if (this._overwrite == 1)
        if (this._siblings[i].length > 1) {
          com.greensock.TweenLite._applyOverwrite(this._targets[i], this, null, 1, this._siblings[i]);
        }
    }
  } else {
    this._propLookup = {};
    this._siblings = com.greensock.TweenLite._tweenLookup[target];
    if (this._siblings == null) {
      this._siblings = com.greensock.TweenLite._tweenLookup[target] = [this];
    } else {
      this._siblings[this._siblings.length] = this;
      if (this._overwrite == 1) {
        com.greensock.TweenLite._applyOverwrite(target, this, null, 1, this._siblings);
      }
    }
  }
  if (this.vars.immediateRender || (duration == 0 && this._delay == 0 && this.vars.immediateRender != false)) {
    this.render(-this._delay, false, true);
  }
};
goog.inherits(com.greensock.TweenLite, com.greensock.core.Animation);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('com.greensock.TweenLite', com.greensock.TweenLite);


/**
 * @export
 * @const
 * @type {string}
 */
com.greensock.TweenLite.version = "12.1.5";


/**
 * @export
 * @type {com.greensock.easing.Ease}
 */
com.greensock.TweenLite.defaultEase = new com.greensock.easing.Ease(null, null, 1, 1);


/**
 * @export
 * @type {string}
 */
com.greensock.TweenLite.defaultOverwrite = "auto";


/**
 * @export
 * @type {flash.display.Shape}
 */
com.greensock.TweenLite.ticker = com.greensock.core.Animation.ticker;


/**
 * @export
 * @type {Object}
 */
com.greensock.TweenLite._plugins = {};


/**
 * @export
 * @type {Function}
 */
com.greensock.TweenLite._onPluginEvent;


/**
 * @protected
 * @type {flash.utils.Dictionary}
 */
com.greensock.TweenLite._tweenLookup = new flash.utils.Dictionary(false);


/**
 * @protected
 * @type {Object}
 */
com.greensock.TweenLite._reservedProps = {ease:1, delay:1, overwrite:1, onComplete:1, onCompleteParams:1, onCompleteScope:1, useFrames:1, runBackwards:1, startAt:1, onUpdate:1, onUpdateParams:1, onUpdateScope:1, onStart:1, onStartParams:1, onStartScope:1, onReverseComplete:1, onReverseCompleteParams:1, onReverseCompleteScope:1, onRepeat:1, onRepeatParams:1, onRepeatScope:1, easeParams:1, yoyo:1, onCompleteListener:1, onUpdateListener:1, onStartListener:1, onReverseCompleteListener:1, onRepeatListener:1, orientToBezier:1, immediateRender:1, repeat:1, repeatDelay:1, data:1, paused:1, reversed:1};


/**
 * @protected
 * @type {Object}
 */
com.greensock.TweenLite._overwriteLookup;


/**
 * @export
 * @type {Object}
 */
com.greensock.TweenLite.prototype.target;


/**
 * @export
 * @type {number}
 */
com.greensock.TweenLite.prototype.ratio;


/**
 * @export
 * @type {Object}
 */
com.greensock.TweenLite.prototype._propLookup;


/**
 * @export
 * @type {com.greensock.core.PropTween}
 */
com.greensock.TweenLite.prototype._firstPT;


/**
 * @protected
 * @type {Array}
 */
com.greensock.TweenLite.prototype._targets;


/**
 * @export
 * @type {com.greensock.easing.Ease}
 */
com.greensock.TweenLite.prototype._ease;


/**
 * @protected
 * @type {number}
 */
com.greensock.TweenLite.prototype._easeType = 0;


/**
 * @protected
 * @type {number}
 */
com.greensock.TweenLite.prototype._easePower = 0;


/**
 * @protected
 * @type {Array}
 */
com.greensock.TweenLite.prototype._siblings;


/**
 * @protected
 * @type {number}
 */
com.greensock.TweenLite.prototype._overwrite = 0;


/**
 * @protected
 * @type {Object}
 */
com.greensock.TweenLite.prototype._overwrittenProps;


/**
 * @protected
 * @type {boolean}
 */
com.greensock.TweenLite.prototype._notifyPluginsOfEnabled;


/**
 * @protected
 * @type {com.greensock.TweenLite}
 */
com.greensock.TweenLite.prototype._startAt;


/**
 * @asprivate
 * Initializes the tween
 * @protected
 */
com.greensock.TweenLite.prototype._init = function() {
  var /** @type {boolean} */ immediate = this.vars.immediateRender, /** @type {number} */ i = 0, /** @type {boolean} */ initPlugins, /** @type {com.greensock.core.PropTween} */ pt, /** @type {string} */ p, /** @type {Object} */ copy;
  if (this.vars.startAt) {
    if (this._startAt != null) {
      this._startAt.render(-1, true);
    }
    this.vars.startAt.overwrite = 0;
    this.vars.startAt.immediateRender = true;
    this._startAt = new com.greensock.TweenLite(this.target, 0, this.vars.startAt);
    if (immediate) {
      if (this._time > 0) {
        this._startAt = null;
      } else if (this._duration !== 0) {
        return;
      }
    }
  } else if (this.vars.runBackwards && this._duration !== 0) {
    if (this._startAt != null) {
      this._startAt.render(-1, true);
      this._startAt = null;
    } else {
      copy = {};
      for (p in this.vars) {
        if (!(p in com.greensock.TweenLite._reservedProps)) {
          copy[p] = this.vars[p];
        }
      }
      copy.overwrite = 0;
      copy.data = "isFromStart";
      this._startAt = com.greensock.TweenLite.to(this.target, 0, copy);
      if (!immediate) {
        this._startAt.render(-1, true);
      } else if (this._time === 0) {
        return;
      }
    }
  }
  if (org.apache.royale.utils.Language.is(this.vars.ease, com.greensock.easing.Ease)) {
    this._ease = org.apache.royale.utils.Language.is(this.vars.easeParams, Array) ? this.vars.ease.config.apply(this.vars.ease, this.vars.easeParams) : this.vars.ease;
  } else if (typeof((this.vars.ease)) === "function") {
    this._ease = new com.greensock.easing.Ease(this.vars.ease, this.vars.easeParams);
  } else {
    this._ease = com.greensock.TweenLite.defaultEase;
  }
  this._easeType = this._ease._type;
  this._easePower = this._ease._power;
  this._firstPT = null;
  if (this._targets) {
    i = this._targets.length;
    while (--i > -1) {
      if (this._initProps(this._targets[i], (this._propLookup[i] = {}), this._siblings[i], (this._overwrittenProps ? this._overwrittenProps[i] : null))) {
        initPlugins = true;
      }
    }
  } else {
    initPlugins = this._initProps(this.target, this._propLookup, this._siblings, this._overwrittenProps);
  }
  if (initPlugins) {
    com.greensock.TweenLite._onPluginEvent("_onInitAllProps", this);
  }
  if (this._overwrittenProps)
    if (this._firstPT == null)
      if (typeof(this.target) !== "function") {
        this._enabled(false, false);
      }
  if (this.vars.runBackwards) {
    pt = this._firstPT;
    while (pt) {
      pt.s += pt.c;
      pt.c = -pt.c;
      pt = pt._next;
    }
  }
  this._onUpdate = this.vars.onUpdate;
  this._initted = true;
};


/** @asprivate Loops through the <code>vars</code> properties, captures starting values, triggers overwriting if necessary, etc. *
 * @protected
 * @param {Object} target
 * @param {Object} propLookup
 * @param {Array} siblings
 * @param {Object} overwrittenProps
 * @return {boolean}
 */
com.greensock.TweenLite.prototype._initProps = function(target, propLookup, siblings, overwrittenProps) {
  var /** @type {Object} */ vars = this.vars, /** @type {string} */ p, /** @type {number} */ i = 0, /** @type {boolean} */ initPlugins, /** @type {Object} */ plugin, /** @type {Object} */ val;
  if (target == null) {
    return false;
  }
  for (p in vars) {
    val = vars[p];
    if (p in com.greensock.TweenLite._reservedProps) {
      if (org.apache.royale.utils.Language.is(val, Array))
        if (val.join("").indexOf("{self}") !== -1) {
          vars[p] = this._swapSelfInParams(org.apache.royale.utils.Language.as(val, Array));
        }
    } else if ((p in com.greensock.TweenLite._plugins) && (plugin = new com.greensock.TweenLite._plugins[p]())._onInitTween(target, val, this)) {
      this._firstPT = new com.greensock.core.PropTween(plugin, "setRatio", 0, 1, p, true, this._firstPT, plugin._priority);
      i = Number(plugin._overwriteProps.length);
      while (--i > -1) {
        propLookup[plugin._overwriteProps[i]] = this._firstPT;
      }
      if (plugin._priority || ("_onInitAllProps" in plugin)) {
        initPlugins = true;
      }
      if (("_onDisable" in plugin) || ("_onEnable" in plugin)) {
        this._notifyPluginsOfEnabled = true;
      }
    } else {
      this._firstPT = propLookup[p] = new com.greensock.core.PropTween(target, p, 0, 1, p, false, this._firstPT);
      this._firstPT.s = Number((!this._firstPT.f) ? Number(target[p]) : target[((p.indexOf("set") || !("get" + p.substr(3) in target)) ? p : "get" + p.substr(3))]());
      this._firstPT.c = (typeof(val) === "number") ? Number(val) - this._firstPT.s : (typeof(val) === "string" && val.charAt(1) === "=") ? org.apache.royale.utils.Language._int(val.charAt(0) + "1") * Number(val.substr(2)) : Number(val) || 0;
    }
  }
  if (overwrittenProps)
    if (this._kill(overwrittenProps, target)) {
      return this._initProps(target, propLookup, siblings, overwrittenProps);
    }
  if (this._overwrite > 1)
    if (this._firstPT != null)
      if (siblings.length > 1)
        if (com.greensock.TweenLite._applyOverwrite(target, this, propLookup, this._overwrite, siblings)) {
          this._kill(propLookup, target);
          return this._initProps(target, propLookup, siblings, overwrittenProps);
        }
  return initPlugins;
};


/** @asprivate (see Animation.render() for notes) *
 * @export
 * @override
 */
com.greensock.TweenLite.prototype.render = function(time, suppressEvents, force) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  force = typeof force !== 'undefined' ? force : false;
  var /** @type {boolean} */ isComplete, /** @type {string} */ callback, /** @type {com.greensock.core.PropTween} */ pt, /** @type {number} */ rawPrevTime, /** @type {number} */ prevTime = this._time;
  if (time >= this._duration) {
    this._totalTime = this._time = this._duration;
    this.ratio = this._ease._calcEnd ? this._ease.getRatio(1) : 1;
    if (!this._reversed) {
      isComplete = true;
      callback = "onComplete";
    }
    if (this._duration == 0) {
      rawPrevTime = this._rawPrevTime;
      if (this._startTime === this._timeline._duration) {
        time = 0;
      }
      if (time === 0 || rawPrevTime < 0 || rawPrevTime === com.greensock.core.Animation._tinyNum)
        if (rawPrevTime !== time) {
          force = true;
          if (rawPrevTime > 0 && rawPrevTime !== com.greensock.core.Animation._tinyNum) {
            callback = "onReverseComplete";
          }
        }
      this._rawPrevTime = rawPrevTime = (!suppressEvents || time !== 0 || this._rawPrevTime === time) ? time : com.greensock.core.Animation._tinyNum;
    }
  } else if (time < 0.0000001) {
    this._totalTime = this._time = 0;
    this.ratio = this._ease._calcEnd ? this._ease.getRatio(0) : 0;
    if (prevTime !== 0 || (this._duration === 0 && this._rawPrevTime > 0 && this._rawPrevTime !== com.greensock.core.Animation._tinyNum)) {
      callback = "onReverseComplete";
      isComplete = this._reversed;
    }
    if (time < 0) {
      this._active = false;
      if (this._duration == 0) {
        if (this._rawPrevTime >= 0) {
          force = true;
        }
        this._rawPrevTime = rawPrevTime = (!suppressEvents || time !== 0 || this._rawPrevTime === time) ? time : com.greensock.core.Animation._tinyNum;
      }
    } else if (!this._initted) {
      force = true;
    }
  } else {
    this._totalTime = this._time = time;
    if (this._easeType) {
      var /** @type {number} */ r = time / this._duration;
      if (this._easeType == 1 || (this._easeType == 3 && r >= 0.5)) {
        r = 1 - r;
      }
      if (this._easeType == 3) {
        r *= 2;
      }
      if (this._easePower == 1) {
        r *= r;
      } else if (this._easePower == 2) {
        r *= r * r;
      } else if (this._easePower == 3) {
        r *= r * r * r;
      } else if (this._easePower == 4) {
        r *= r * r * r * r;
      }
      if (this._easeType == 1) {
        this.ratio = 1 - r;
      } else if (this._easeType == 2) {
        this.ratio = r;
      } else if (time / this._duration < 0.5) {
        this.ratio = r / 2;
      } else {
        this.ratio = 1 - (r / 2);
      }
    } else {
      this.ratio = this._ease.getRatio(time / this._duration);
    }
  }
  if (this._time == prevTime && !force) {
    return;
  } else if (!this._initted) {
    this._init();
    if (!this._initted || this._gc) {
      return;
    }
    if (this._time && !isComplete) {
      this.ratio = this._ease.getRatio(this._time / this._duration);
    } else if (isComplete && this._ease._calcEnd) {
      this.ratio = this._ease.getRatio((this._time === 0) ? 0 : 1);
    }
  }
  if (!this._active)
    if (!this._paused && this._time !== prevTime && time >= 0) {
      this._active = true;
    }
  if (prevTime == 0) {
    if (this._startAt != null) {
      if (time >= 0) {
        this._startAt.render(time, suppressEvents, force);
      } else if (!callback) {
        callback = "_dummyGS";
      }
    }
    if (this.vars.onStart)
      if (this._time != 0 || this._duration == 0)
        if (!suppressEvents) {
          this.vars.onStart.apply(null, this.vars.onStartParams);
        }
  }
  pt = this._firstPT;
  while (pt) {
    if (pt.f) {
      pt.t[pt.p](pt.c * this.ratio + pt.s);
    } else {
      pt.t[pt.p] = pt.c * this.ratio + pt.s;
    }
    pt = pt._next;
  }
  if (this._onUpdate != null) {
    if (time < 0 && this._startAt != null && this._startTime != 0) {
      this._startAt.render(time, suppressEvents, force);
    }
    if (!suppressEvents)
      if (this._time !== prevTime || isComplete) {
        this._onUpdate.apply(null, this.vars.onUpdateParams);
      }
  }
  if (callback)
    if (!this._gc) {
      if (time < 0 && this._startAt != null && this._onUpdate == null && this._startTime != 0) {
        this._startAt.render(time, suppressEvents, force);
      }
      if (isComplete) {
        if (this._timeline.autoRemoveChildren) {
          this._enabled(false, false);
        }
        this._active = false;
      }
      if (!suppressEvents)
        if (this.vars[callback]) {
          this.vars[callback].apply(null, this.vars[callback + "Params"]);
        }
      if (this._duration === 0 && this._rawPrevTime === com.greensock.core.Animation._tinyNum && rawPrevTime !== com.greensock.core.Animation._tinyNum) {
        this._rawPrevTime = 0;
      }
    }
};


/** @asprivate Same as <code>kill()</code> except that it returns a Boolean indicating if any significant properties were changed (some plugins like MotionBlurPlugin may perform cleanup tasks that alter alpha, etc.). *
 * @export
 * @override
 */
com.greensock.TweenLite.prototype._kill = function(vars, target) {
  vars = typeof vars !== 'undefined' ? vars : null;
  target = typeof target !== 'undefined' ? target : null;
  if (vars === "all") {
    vars = null;
  }
  if (vars == null)
    if (target == null || target == this.target) {
      return this._enabled(false, false);
    }
  target = target || this._targets || this.target;
  var /** @type {number} */ i = 0, /** @type {Object} */ overwrittenProps, /** @type {string} */ p, /** @type {com.greensock.core.PropTween} */ pt, /** @type {Object} */ propLookup, /** @type {boolean} */ changed, /** @type {Object} */ killProps, /** @type {boolean} */ record;
  if (org.apache.royale.utils.Language.is(target, Array) && typeof(target[0]) === "object") {
    i = Number(target.length);
    while (--i > -1) {
      if (this._kill(vars, target[i])) {
        changed = true;
      }
    }
  } else {
    if (this._targets) {
      i = this._targets.length;
      while (--i > -1) {
        if (target === this._targets[i]) {
          propLookup = this._propLookup[i] || {};
          this._overwrittenProps = this._overwrittenProps || [];
          overwrittenProps = this._overwrittenProps[i] = vars ? this._overwrittenProps[i] || {} : "all";
          break;
        }
      }
    } else if (target !== this.target) {
      return false;
    } else {
      propLookup = this._propLookup;
      overwrittenProps = this._overwrittenProps = vars ? this._overwrittenProps || {} : "all";
    }
    if (propLookup) {
      killProps = vars || propLookup;
      record = (vars != overwrittenProps && overwrittenProps != "all" && vars != propLookup && (typeof(vars) != "object" || vars._tempKill != true));
      for (p in killProps) {
        pt = propLookup[p];
        if (pt != null) {
          if (pt.pg && pt.t._kill(killProps)) {
            changed = true;
          }
          if (!pt.pg || pt.t._overwriteProps.length === 0) {
            if (pt._prev) {
              pt._prev._next = pt._next;
            } else if (pt == this._firstPT) {
              this._firstPT = pt._next;
            }
            if (pt._next) {
              pt._next._prev = pt._prev;
            }
            pt._next = pt._prev = null;
          }
          delete propLookup[p];
        }
        if (record) {
          overwrittenProps[p] = 1;
        }
      }
      if (this._firstPT == null && this._initted) {
        this._enabled(false, false);
      }
    }
  }
  return changed;
};


/** @inheritDoc *
 * @export
 * @override
 */
com.greensock.TweenLite.prototype.invalidate = function() {
  if (this._notifyPluginsOfEnabled) {
    com.greensock.TweenLite._onPluginEvent("_onDisable", this);
  }
  this._firstPT = null;
  this._overwrittenProps = null;
  this._onUpdate = null;
  this._startAt = null;
  this._initted = this._active = this._notifyPluginsOfEnabled = false;
  this._propLookup = this._targets ? {} : [];
  return this;
};


/** @asprivate (see Animation._enabled() for notes) *
 * @export
 * @override
 */
com.greensock.TweenLite.prototype._enabled = function(enabled, ignoreTimeline) {
  ignoreTimeline = typeof ignoreTimeline !== 'undefined' ? ignoreTimeline : false;
  if (enabled && this._gc) {
    if (this._targets) {
      var /** @type {number} */ i = this._targets.length;
      while (--i > -1) {
        this._siblings[i] = com.greensock.TweenLite._register(this._targets[i], this, true);
      }
    } else {
      this._siblings = com.greensock.TweenLite._register(this.target, this, true);
    }
  }
  com.greensock.TweenLite.superClass_._enabled.apply(this, [ enabled, ignoreTimeline] );
  if (this._notifyPluginsOfEnabled)
    if (this._firstPT != null) {
      return com.greensock.TweenLite._onPluginEvent((enabled ? "_onEnable" : "_onDisable"), this);
    }
  return false;
};


/**
 * Static method for creating a TweenLite instance that animates to the specified destination values
 * (from the current values). The following lines of code all produce identical results: 
 * 
 * <listing version="3.0">
 
 
 
 
 * 
 * <p>Each line above will tween the <code>"x"</code> property of the <code>mc</code> object 
 * to a value of 100 over the coarse of 1 second. They each use a slightly different syntax,
 * all of which are valid. If you don't need to store a reference of the tween, just use the 
 * static <code>TweenLite.to( )</code> call.</p>
 * 
 * <p>Since the <code>target</code> parameter can also be an array of objects, the following 
 * code will tween the x property of mc1, mc2, and mc3 to a value of 100 simultaneously:</p>
 * 
 * <listing version="3.0">
 
 
 * <p>Even though 3 objects are animating, there is still only one tween created. 
 * In order to stagger or offset the start times of each object animating, please see 
 * the <code>staggerTo()</code> method of TimelineLite or TweenMax.</p>
 * 
 * <p>For simple sequencing, you can use the <code>delay</code> special property
 * (like <code>TweenLite.to(mc, 1, {x:100, delay:0.5})</code>), 
 * but it is highly recommended that you consider using TimelineLite (or TimelineMax) 
 * for all but the simplest sequencing tasks. It has an identical <code>to()</code> method
 * that allows you to append tweens one-after-the-other and then control the entire sequence 
 * as a whole. You can even have the tweens overlap as much as you want.</p>
 * 
 * @asparam target Target object (or array of objects) whose properties this tween affects. 
 * @asparam duration Duration in seconds (or frames if <code>useFrames:true</code> is set in the <code>vars</code> parameter)
 * @asparam vars An object defining the end value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> to 100 and <code>mc.y</code> to 200 and then call <code>myFunction</code>, do this: <code>TweenLite.to(mc, 1, {x:100, y:200, onComplete:myFunction});</code>
 * @asreturn TweenLite instance
 * @see com.greensock.TimelineLite#to()
 * @see com.greensock.TimelineLite#staggerTo()
 * @see com.greensock.TweenMax#staggerTo()
 * @see #from()
 * @see #fromTo()
 * @export
 * @param {Object} target
 * @param {number} duration
 * @param {Object} vars
 * @return {com.greensock.TweenLite}
 */
com.greensock.TweenLite.to = function(target, duration, vars) {
  return new com.greensock.TweenLite(target, duration, vars);
};


/**
 * Static method for creating a TweenLite instance that tweens backwards - 
 * you define the <strong>BEGINNING</strong> values and the current values are used
 * as the destination values which is great for doing things like animating objects
 * onto the screen because you can set them up initially the way you want them to look 
 * at the end of the tween and then animate in from elsewhere.
 * 
 * <p><strong>NOTE:</strong> By default, <code>immediateRender</code> is <code>true</code> in 
 * <code>from()</code> tweens, meaning that they immediately render their starting state 
 * regardless of any delay that is specified. You can override this behavior by passing 
 * <code>immediateRender:false</code> in the <code>vars</code> parameter so that it will 
 * wait to render until the tween actually begins (often the desired behavior when inserting 
 * into TimelineLite or TimelineMax instances). To illustrate the default behavior, the 
 * following code will immediately set the <code>alpha</code> of <code>mc</code> 
 * to 0 and then wait 2 seconds before tweening the <code>alpha</code> back to 1 over
 * the course of 1.5 seconds:</p>
 * 
 * <p><code>
 * TweenLite.from(mc, 1.5, {alpha:0, delay:2});
 * </code></p>
 * 
 * <p>Since the <code>target</code> parameter can also be an array of objects, the following 
 * code will tween the alpha property of mc1, mc2, and mc3 from a value of 0 simultaneously:</p>
 * 
 * <listing version="3.0">
 
 
 * <p>Even though 3 objects are animating, there is still only one tween created. 
 * In order to stagger or offset the start times of each object animating, please see 
 * the <code>staggerFrom()</code> method of TimelineLite or TweenMax.</p>
 * 
 * <p>For simple sequencing, you can use the <code>delay</code> special property
 * (like <code>TweenLite.from(mc, 1, {alpha:0, delay:0.5})</code>), 
 * but it is highly recommended that you consider using TimelineLite (or TimelineMax) 
 * for all but the simplest sequencing tasks. It has an identical <code>from()</code> method
 * that allows you to append tweens one-after-the-other and then control the entire sequence 
 * as a whole. You can even have the tweens overlap as much as you want.</p>
 * 
 * @asparam target Target object (or array of objects) whose properties this tween affects.  
 * @asparam duration Duration in seconds (or frames if <code>useFrames:true</code> is set in the <code>vars</code> parameter)
 * @asparam vars An object defining the starting value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> from 100 and <code>mc.y</code> from 200 and then call <code>myFunction</code>, do this: <code>TweenLite.from(mc, 1, {x:100, y:200, onComplete:myFunction});</code>
 * @asreturn TweenLite instance
 * @see #to()
 * @see #fromTo()
 * @see com.greensock.TimelineLite#from()
 * @see com.greensock.TimelineLite#staggerFrom()
 * @see com.greensock.TweenMax#staggerFrom()
 * @export
 * @param {Object} target
 * @param {number} duration
 * @param {Object} vars
 * @return {com.greensock.TweenLite}
 */
com.greensock.TweenLite.from = function(target, duration, vars) {
  vars = com.greensock.TweenLite._prepVars(vars, true);
  vars.runBackwards = true;
  return new com.greensock.TweenLite(target, duration, vars);
};


/**
 * Static method for creating a TweenLite instance that allows you to define both the starting
 * and ending values (as opposed to <code>to()</code> and <code>from()</code> tweens which are 
 * based on the target's current values at one end or the other).
 * 
 * <p><strong>NOTE</strong>: Only put starting values in the <code>fromVars</code> parameter - all 
 * special properties for the tween (like onComplete, onUpdate, delay, etc.) belong in the <code>toVars</code> 
 * parameter. </p>
 * 
 * <p>By default, <code>immediateRender</code> is <code>true</code> in 
 * <code>fromTo()</code> tweens, meaning that they immediately render their starting state 
 * regardless of any delay that is specified. This is done for convenience because it is 
 * often the preferred behavior when setting things up on the screen to animate into place, but 
 * you can override this behavior by passing <code>immediateRender:false</code> in the 
 * <code>fromVars</code> or <code>toVars</code> parameter so that it will wait to render 
 * the starting values until the tween actually begins (often the desired behavior when inserting 
 * into TimelineLite or TimelineMax instances).</p>
 * 
 * <p>Since the <code>target</code> parameter can also be an array of objects, the following 
 * code will tween the x property of mc1, mc2, and mc3 from 0 to 100 simultaneously:</p>
 * 
 * <listing version="3.0">
 
 
 * <p>Even though 3 objects are animating, there is still only one tween created. 
 * In order to stagger or offset the start times of each object animating, please see 
 * the <code>staggerFromTo()</code> method of TimelineLite or TweenMax.</p>
 * 
 * <p>For simple sequencing, you can use the <code>delay</code> special property
 * (like <code>TweenLite.fromTo(mc, 1, {x:0}, {x:100, delay:0.5})</code>), 
 * but it is highly recommended that you consider using TimelineLite (or TimelineMax) 
 * for all but the simplest sequencing tasks. It has an identical <code>fromTo()</code> method
 * that allows you to append tweens one-after-the-other and then control the entire sequence 
 * as a whole. You can even have the tweens overlap as much as you want.</p>
 * 
 * @asparam target Target object (or array of objects) whose properties this tween affects. 
 * @asparam duration Duration in seconds (or frames if <code>useFrames:true</code> is set in the <code>vars</code> parameter)
 * @asparam fromVars An object defining the starting value for each property that should be tweened. For example, to tween <code>mc.x</code> from 100 and <code>mc.y</code> from 200, <code>fromVars</code> would look like this: <code>{x:100, y:200}</code>.
 * @asparam toVars An object defining the end value for each property that should be tweened as well as any special properties like <code>onComplete</code>, <code>ease</code>, etc. For example, to tween <code>mc.x</code> from 0 to 100 and <code>mc.y</code> from 0 to 200 and then call <code>myFunction</code>, do this: <code>TweenLite.fromTo(mc, 1, {x:0, y:0}, {x:100, y:200, onComplete:myFunction});</code>
 * @asreturn TweenLite instance
 * @see #to()
 * @see #from()
 * @see com.greensock.TimelineLite#fromTo()
 * @see com.greensock.TimelineLite#staggerFromTo()
 * @see com.greensock.TweenMax#staggerFromTo()
 * @export
 * @param {Object} target
 * @param {number} duration
 * @param {Object} fromVars
 * @param {Object} toVars
 * @return {com.greensock.TweenLite}
 */
com.greensock.TweenLite.fromTo = function(target, duration, fromVars, toVars) {
  toVars = com.greensock.TweenLite._prepVars(toVars, true);
  fromVars = com.greensock.TweenLite._prepVars(fromVars);
  toVars.startAt = fromVars;
  toVars.immediateRender = (toVars.immediateRender != false && fromVars.immediateRender != false);
  return new com.greensock.TweenLite(target, duration, toVars);
};


/** @asprivate Accommodates TweenLiteVars instances for strong data typing and code hinting *
 * @protected
 * @param {Object} vars
 * @param {boolean=} immediateRender
 * @return {Object}
 */
com.greensock.TweenLite._prepVars = function(vars, immediateRender) {
  immediateRender = typeof immediateRender !== 'undefined' ? immediateRender : false;
  if (vars._isGSVars) {
    vars = vars.vars;
  }
  if (immediateRender && !("immediateRender" in vars)) {
    vars.immediateRender = true;
  }
  return vars;
};


/**
 * Provides a simple way to call a function after a set amount of time (or frames). You can
 * optionally pass any number of parameters to the function too.
 * 
 * <p><strong>JavaScript and AS2 note:</strong> - Due to the way JavaScript and AS2 don't 
 * maintain scope (what "<code>this</code>" refers to, or the context) in function calls, 
 * it can be useful to define the scope specifically. Therefore, in the JavaScript and AS2 
 * versions the 4th parameter is <code>scope</code>, bumping <code>useFrames</code> 
 * back to the 5th parameter:</p>
 * 
 * <p><code>TweenLite.delayedCall(delay, callback, params, scope, useFrames)</code> <em>[JavaScript and AS2 only]</em></p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 * 
 * @asparam delay Delay in seconds (or frames if <code>useFrames</code> is <code>true</code>) before the function should be called
 * @asparam callback Function to call
 * @asparam params An Array of parameters to pass the function (optional).
 * @asparam useFrames If the delay should be measured in frames instead of seconds, set <code>useFrames</code> to <code>true</code> (default is <code>false</code>)
 * @asreturn TweenLite instance
 * @see com.greensock.TimelineLite#call()
 * @see com.greensock.TimelineMax#addCallback()
 * @export
 * @param {number} delay
 * @param {Function} callback
 * @param {Array=} params
 * @param {boolean=} useFrames
 * @return {com.greensock.TweenLite}
 */
com.greensock.TweenLite.delayedCall = function(delay, callback, params, useFrames) {
  params = typeof params !== 'undefined' ? params : null;
  useFrames = typeof useFrames !== 'undefined' ? useFrames : false;
  return new com.greensock.TweenLite(callback, 0, {delay:delay, onComplete:callback, onCompleteParams:params, onReverseComplete:callback, onReverseCompleteParams:params, immediateRender:false, useFrames:useFrames, overwrite:0});
};


/**
 * Immediately sets properties of the target accordingly - essentially a zero-duration to() tween with a more 
 * intuitive name. So the following lines produce identical results:
 * 
 * <listing version="3.0">
 
 
 
 * 
 * <p>And of course you can use an array to set the properties of multiple targets at the same time, like:</p>
 * 
 * <listing version="3.0">
 
 
 * 
 * @asparam target Target object (or array of objects) whose properties will be affected. 
 * @asparam vars An object defining the value for each property that should be set. For example, to set <code>mc.x</code> to 100 and <code>mc.y</code> to 200, do this: <code>TweenLite.set(mc, {x:100, y:200});</code>
 * @asreturn A TweenLite instance (with a duration of 0) which can optionally be inserted into a TimelineLite/Max instance (although it's typically more concise to just use the timeline's <code>set()</code> method).
 * @export
 * @param {Object} target
 * @param {Object} vars
 * @return {com.greensock.TweenLite}
 */
com.greensock.TweenLite.set = function(target, vars) {
  return new com.greensock.TweenLite(target, 0, vars);
};


/** @asprivate *
 * @private
 * @param {flash.events.Event} event
 */
com.greensock.TweenLite._dumpGarbage = function(event) {
  if ((com.greensock.core.Animation._rootFrame / 60) >> 0 === com.greensock.core.Animation._rootFrame / 60) {
    var /** @type {number} */ i = 0, /** @type {Array} */ a, /** @type {Object} */ tgt;
    for (tgt in com.greensock.TweenLite._tweenLookup) {
      a = com.greensock.TweenLite._tweenLookup[tgt];
      i = a.length;
      while (--i > -1) {
        if (a[i]._gc) {
          a.splice(i, 1);
        }
      }
      if (a.length === 0) {
        delete com.greensock.TweenLite._tweenLookup[tgt];
      }
    }
  }
};


/**
 * Kills all the tweens (or specific tweening properties) of a particular object or delayedCalls 
 * to a particular function. If, for example, you want to kill all tweens of <code>myObject</code>, 
 * you'd do this:
 * 
 * <p><code>
 * TweenLite.killTweensOf(myObject);
 * </code></p>
 * 
 * <p>To kill only active (currently animating) tweens of <code>myObject</code>, you'd do this:</p>
 * 
 * <p><code>
 * TweenLite.killTweensOf(myObject, true);
 * </code></p>
 * 
 * <p>To kill only particular tweening properties of the object, use the third parameter. 
 * For example, if you only want to kill all the tweens of <code>myObject.alpha</code> and 
 * <code>myObject.x</code>, you'd do this:</p>
 * 
 * <p><code>
 * TweenLite.killTweensOf(myObject, false, {alpha:true, x:true});
 * </code></p>
 * 
 * <p>To kill all the delayedCalls that were created like <code>TweenLite.delayedCall(5, myFunction);</code>, 
 * you can simply call <code>TweenLite.killTweensOf(myFunction);</code> because delayedCalls 
 * are simply tweens that have their <code>target</code> and <code>onComplete</code> set to 
 * the same function (as well as a <code>delay</code> of course).</p>
 * 
 * <p><code>killTweensOf()</code> affects tweens that haven't begun yet too. If, for example, 
 * a tween of <code>myObject</code> has a <code>delay</code> of 5 seconds and 
 * <code>TweenLite.killTweensOf(mc)</code> is called 2 seconds after the tween was created, 
 * it will still be killed even though it hasn't started yet. </p>
 * 
 * @asparam target Object whose tweens should be killed immediately or selector text to feed the selector engine to find the target(s).
 * @asparam onlyActive If <code>true</code>, only tweens that are currently active will be killed (a tween is considered "active" if the virtual playhead is actively moving across the tween and it is not paused, nor are any of its ancestor timelines paused). 
 * @asparam vars To kill only specific properties, use a generic object containing enumerable properties corresponding to the ones that should be killed like <code>{x:true, y:true}</code>. The values assigned to each property of the object don't matter - the sole purpose of the object is for iteration over the named properties (in this case, <code>x</code> and <code>y</code>). If no object (or <code>null</code>) is defined, all matched tweens will be killed in their entirety.
 * @export
 * @param {*} target
 * @param {*=} onlyActive
 * @param {Object=} vars
 */
com.greensock.TweenLite.killTweensOf = function(target, onlyActive, vars) {
  onlyActive = typeof onlyActive !== 'undefined' ? onlyActive : false;
  vars = typeof vars !== 'undefined' ? vars : null;
  if (typeof(onlyActive) === "object") {
    vars = onlyActive;
    onlyActive = false;
  }
  var /** @type {Array} */ a = com.greensock.TweenLite.getTweensOf(target, onlyActive), /** @type {number} */ i = a.length;
  while (--i > -1) {
    a[i]._kill(vars, target);
  }
};


/**
 * Immediately kills all of the delayedCalls to a particular function. If, for example, 
 * you want to kill all delayedCalls to <code>myFunction</code>, you'd do this:
 * 
 * <p><code>
 * TweenLite.killDelayedCallsTo(myFunction);
 * </code></p>
 * 
 * <p>Since a delayedCall is just a tween that uses the function/callback as both its <code>target</code>
 * and its <code>onComplete</code>, <code>TweenLite.killTweensOf(myFunction)</code> produces exactly the 
 * same result as <code>TweenLite.killDelayedCallsTo(myFunction)</code>.</p>
 * 
 * <p>This method affects all delayedCalls that were created using <code>TweenLite.delayedCall()</code>
 * or <code>TweenMax.delayedCall()</code> or the <code>call()</code> or <code>addCallback()</code> methods
 * of TimelineLite or TimelineMax. Basically, any tween whose target is the function you supply will 
 * be killed.</p>
 * 
 * @asparam func The function for which all delayedCalls should be killed/cancelled.
 * @export
 * @param {Function} func
 */
com.greensock.TweenLite.killDelayedCallsTo = function(func) {
  com.greensock.TweenLite.killTweensOf(func);
};


/**
 * Returns an array containing all the tweens of a particular target (or group of targets) that have not
 * been released for garbage collection yet which typically happens within a few seconds after the tween completes.
 * For example, <code>TweenLite.getTweensOf(myObject)</code> returns an array of all tweens
 * of <code>myObject</code>, even tweens that haven't begun yet. <code>TweenLite.getTweensOf([myObject1, myObject2]);</code>
 * will return a condensed array of the tweens of <code>myObject1</code> plus all the tweens
 * of <code>myObject2</code> combined into one array with duplicates removed. 
 * 
 * <p>Since the method only finds tweens that haven't been released for garbage collection, if you create a tween
 * and then let it finish and then a while later try to find it with <code>getTweensOf()</code>, it may not be found 
 * because it was released by the engine for garbage collection. Remember, one of the best parts of GSAP is that it 
 * saves you from the headache of managing gc. Otherwise, you'd need to manually dispose each tween you create, making 
 * things much more cumbersome.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 * @asparam target The target whose tweens should be returned, or an array of such targets
 * @asparam onlyActive If <code>true</code>, only tweens that are currently active will be returned (a tween is considered "active" if the virtual playhead is actively moving across the tween and it is not paused, nor are any of its ancestor timelines paused). 
 * @asreturn An array of tweens
 * @export
 * @param {*} target
 * @param {boolean=} onlyActive
 * @return {Array}
 */
com.greensock.TweenLite.getTweensOf = function(target, onlyActive) {
  onlyActive = typeof onlyActive !== 'undefined' ? onlyActive : false;
  var /** @type {number} */ i = 0, /** @type {Array} */ a, /** @type {number} */ j = 0, /** @type {com.greensock.TweenLite} */ t;
  if (org.apache.royale.utils.Language.is(target, Array) && typeof(target[0]) != "string" && typeof(target[0]) != "number") {
    i = Number(target.length);
    a = [];
    while (--i > -1) {
      a = a.concat(com.greensock.TweenLite.getTweensOf(target[i], onlyActive));
    }
    i = a.length;
    while (--i > -1) {
      t = a[i];
      j = i;
      while (--j > -1) {
        if (t === a[j]) {
          a.splice(i, 1);
        }
      }
    }
  } else {
    a = com.greensock.TweenLite._register(target).concat();
    i = a.length;
    while (--i > -1) {
      if (a[i]._gc || (onlyActive && !a[i].isActive())) {
        a.splice(i, 1);
      }
    }
  }
  return a;
};


/** 
 * @asprivate
 * Used for one or more of the following purposes:
 * 1) Register a target, putting it into the lookup/Dictionary for easy lookup later
 * 2) Returns an array of sibling tweens (tweens of the same target)
 * 3) scrubs the siblings array of duplicate instances of the tween (typically only used when re-enabling a tween instance).
 * @protected
 * @param {Object} target
 * @param {com.greensock.TweenLite=} tween
 * @param {boolean=} scrub
 * @return {Array}
 */
com.greensock.TweenLite._register = function(target, tween, scrub) {
  tween = typeof tween !== 'undefined' ? tween : null;
  scrub = typeof scrub !== 'undefined' ? scrub : false;
  var /** @type {Array} */ a = com.greensock.TweenLite._tweenLookup[target], /** @type {number} */ i = 0;
  if (a == null) {
    a = com.greensock.TweenLite._tweenLookup[target] = [];
  }
  if (tween) {
    i = a.length;
    a[i] = tween;
    if (scrub) {
      while (--i > -1) {
        if (a[i] === tween) {
          a.splice(i, 1);
        }
      }
    }
  }
  return a;
};


/** @asprivate Performs overwriting *
 * @protected
 * @param {Object} target
 * @param {com.greensock.TweenLite} tween
 * @param {Object} props
 * @param {number} mode
 * @param {Array} siblings
 * @return {boolean}
 */
com.greensock.TweenLite._applyOverwrite = function(target, tween, props, mode, siblings) {
  var /** @type {number} */ i = 0, /** @type {boolean} */ changed, /** @type {com.greensock.TweenLite} */ curTween;
  if (mode == 1 || mode >= 4) {
    var /** @type {number} */ l = siblings.length;
    for (i = 0; i < l; i++) {
      curTween = siblings[i];
      if (curTween != tween) {
        if (!curTween._gc)
          if (curTween._enabled(false, false)) {
            changed = true;
          }
      } else if (mode == 5) {
        break;
      }
    }
    return changed;
  }
  var /** @type {number} */ startTime = tween._startTime + 0.0000000001, /** @type {Array} */ overlaps = [], /** @type {number} */ oCount = 0, /** @type {boolean} */ zeroDur = (tween._duration == 0), /** @type {number} */ globalStart;
  i = siblings.length;
  while (--i > -1) {
    curTween = siblings[i];
    if (curTween === tween || curTween._gc || curTween._paused) {
    } else if (curTween._timeline != tween._timeline) {
      globalStart = globalStart || com.greensock.TweenLite._checkOverlap(tween, 0, zeroDur);
      if (com.greensock.TweenLite._checkOverlap(curTween, globalStart, zeroDur) === 0) {
        overlaps[oCount++] = curTween;
      }
    }
    else if (curTween._startTime <= startTime)
      if (curTween._startTime + curTween.totalDuration() / curTween._timeScale > startTime)
        if (!((zeroDur || !curTween._initted) && startTime - curTween._startTime <= 0.0000000002)) {
          overlaps[oCount++] = curTween;
        }
  }
  i = oCount;
  while (--i > -1) {
    curTween = overlaps[i];
    if (mode == 2)
      if (curTween._kill(props, target)) {
        changed = true;
      }
    if (mode !== 2 || (!curTween._firstPT && curTween._initted)) {
      if (curTween._enabled(false, false)) {
        changed = true;
      }
    }
  }
  return changed;
};


/** 
 * @asprivate 
 * Checks if a tween overlaps with a particular global time value. "reference" is the point in time on the global (root) timeline, 
 * and if the tween overlaps with it, 0 is returned. If the tween starts AFTER the reference, the difference between the two (positive 
 * value) is returned. If reference is AFTER the end of the tween, the negative offset is given (reference time minus where the end of 
 * the tween is on the global timeline). If the tween lands EXACTLY on the reference, it will check to see if the tween's _initted property 
 * is true. If not, 0.0000000001 is returned, indicating that the tween shouldn't be overwritten. If any of the child's anscestor timelines
 * are paused, -100 is returned. This wraps a lot of functionality into a relatively concise method (keeps file size low and performance high)
 * @private
 * @param {com.greensock.core.Animation} tween
 * @param {number} reference
 * @param {boolean} zeroDur
 * @return {number}
 */
com.greensock.TweenLite._checkOverlap = function(tween, reference, zeroDur) {
  var /** @type {com.greensock.core.SimpleTimeline} */ tl = tween._timeline, /** @type {number} */ ts = tl._timeScale, /** @type {number} */ t = tween._startTime, /** @type {number} */ min = 0.0000000001;
  while (tl._timeline) {
    t += tl._startTime;
    ts *= tl._timeScale;
    if (tl._paused) {
      return -100;
    }
    tl = tl._timeline;
  }
  t /= ts;
  return (t > reference) ? t - reference : ((zeroDur && t == reference) || (!tween._initted && t - reference < 2 * min)) ? min : ((t += tween.totalDuration() / tween._timeScale / ts) > reference + min) ? 0 : t - reference - min;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
com.greensock.TweenLite.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'TweenLite', qName: 'com.greensock.TweenLite', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
com.greensock.TweenLite.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|defaultEase': { type: 'com.greensock.easing.Ease'},
        '|defaultOverwrite': { type: 'String'},
        '|ticker': { type: 'flash.display.Shape'},
        '|_plugins': { type: 'Object'},
        '|_onPluginEvent': { type: 'Function'},
        'target': { type: 'Object'},
        'ratio': { type: 'Number'},
        '_propLookup': { type: 'Object'},
        '_firstPT': { type: 'com.greensock.core.PropTween'},
        '_ease': { type: 'com.greensock.easing.Ease'}
      };
    },
    accessors: function () {return {};},
    methods: function () {
      return {
        'TweenLite': { type: '', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false } ]; }},
        'render': { type: 'void', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Boolean', optional: true } ]; }},
        '_kill': { type: 'Boolean', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Object', optional: true },{ index: 2, type: 'Object', optional: true } ]; }},
        'invalidate': { type: '*', declaredBy: 'com.greensock.TweenLite'},
        '_enabled': { type: 'Boolean', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Boolean', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        '|to': { type: 'com.greensock.TweenLite', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false } ]; }},
        '|from': { type: 'com.greensock.TweenLite', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false } ]; }},
        '|fromTo': { type: 'com.greensock.TweenLite', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Number', optional: false },{ index: 3, type: 'Object', optional: false },{ index: 4, type: 'Object', optional: false } ]; }},
        '|delayedCall': { type: 'com.greensock.TweenLite', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Function', optional: false },{ index: 3, type: 'Array', optional: true },{ index: 4, type: 'Boolean', optional: true } ]; }},
        '|set': { type: 'com.greensock.TweenLite', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Object', optional: false },{ index: 2, type: 'Object', optional: false } ]; }},
        '|killTweensOf': { type: 'void', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: '*', optional: true },{ index: 3, type: 'Object', optional: true } ]; }},
        '|killDelayedCallsTo': { type: 'void', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: 'Function', optional: false } ]; }},
        '|getTweensOf': { type: 'Array', declaredBy: 'com.greensock.TweenLite', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }}
      };
    }
  };
};
