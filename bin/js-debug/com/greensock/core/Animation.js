/**
 * Generated by Apache Royale Compiler from com\greensock\core\Animation.as
 * com.greensock.core.Animation
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('com.greensock.core.Animation');
/* Royale Dependency List: com.greensock.core.SimpleTimeline,flash.utils.getTimer,org.apache.royale.utils.Language,XML*/
/* Royale Static Dependency List: flash.display.Shape,flash.events.Event*/

goog.require('flash.display.Shape');
goog.require('flash.events.Event');



/**
 * Constructor 
 * 
 * @asparam duration duration in seconds (or frames for frames-based tweens)
 * @asparam vars configuration variables (for example, <code>{x:100, y:0, opacity:0.5, onComplete:myFunction}</code>)
 * @constructor
 * @param {number=} duration
 * @param {Object=} vars
 */
com.greensock.core.Animation = function(duration, vars) {
  duration = typeof duration !== 'undefined' ? duration : 0;
  vars = typeof vars !== 'undefined' ? vars : null;
  this.vars = vars || {};
  if (this.vars._isGSVars) {
    this.vars = this.vars.vars;
  }
  this._duration = this._totalDuration = duration || 0;
  this._delay = Number(this.vars.delay) || 0;
  this._timeScale = 1;
  this._totalTime = this._time = 0;
  this.data = this.vars.data;
  this._rawPrevTime = -1;
  if (com.greensock.core.Animation._rootTimeline == null) {
    if (com.greensock.core.Animation._rootFrame == -1) {
      com.greensock.core.Animation._rootFrame = 0;
      com.greensock.core.Animation._rootFramesTimeline = new com.greensock.core.SimpleTimeline();
      com.greensock.core.Animation._rootTimeline = new com.greensock.core.SimpleTimeline();
      com.greensock.core.Animation._rootTimeline._startTime = flash.utils.getTimer() / 1000;
      com.greensock.core.Animation._rootFramesTimeline._startTime = 0;
      com.greensock.core.Animation._rootTimeline._active = com.greensock.core.Animation._rootFramesTimeline._active = true;
      com.greensock.core.Animation.ticker.addEventListener("enterFrame", com.greensock.core.Animation._updateRoot, false, 0, true);
    } else {
      return;
    }
  }
  var /** @type {com.greensock.core.SimpleTimeline} */ tl = (this.vars.useFrames) ? com.greensock.core.Animation._rootFramesTimeline : com.greensock.core.Animation._rootTimeline;
  tl.add(this, tl._time);
  this._reversed = (this.vars.reversed == true);
  if (this.vars.paused) {
    this.paused(true);
  }
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('com.greensock.core.Animation', com.greensock.core.Animation);


/**
 * @export
 * @const
 * @type {string}
 */
com.greensock.core.Animation.version = "12.1.1";


/**
 * @export
 * @type {flash.display.Shape}
 */
com.greensock.core.Animation.ticker = new flash.display.Shape();


/**
 * @export
 * @type {com.greensock.core.SimpleTimeline}
 */
com.greensock.core.Animation._rootTimeline;


/**
 * @export
 * @type {com.greensock.core.SimpleTimeline}
 */
com.greensock.core.Animation._rootFramesTimeline;


/**
 * @protected
 * @type {number}
 */
com.greensock.core.Animation._rootFrame = -1;


/**
 * @protected
 * @type {flash.events.Event}
 */
com.greensock.core.Animation._tickEvent = new flash.events.Event("tick");


/**
 * @protected
 * @type {number}
 */
com.greensock.core.Animation._tinyNum = 0.0000000001;


/**
 * @protected
 * @type {Function}
 */
com.greensock.core.Animation.prototype._onUpdate;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._delay;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._rawPrevTime;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.Animation.prototype._active;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.Animation.prototype._gc;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.Animation.prototype._initted;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._startTime;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._time;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._totalTime;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._duration;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._totalDuration;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._pauseTime;


/**
 * @export
 * @type {number}
 */
com.greensock.core.Animation.prototype._timeScale;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.Animation.prototype._reversed;


/**
 * @export
 * @type {com.greensock.core.SimpleTimeline}
 */
com.greensock.core.Animation.prototype._timeline;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.Animation.prototype._dirty;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.Animation.prototype._paused;


/**
 * @export
 * @type {com.greensock.core.Animation}
 */
com.greensock.core.Animation.prototype._next;


/**
 * @export
 * @type {com.greensock.core.Animation}
 */
com.greensock.core.Animation.prototype._prev;


/**
 * @export
 * @type {Object}
 */
com.greensock.core.Animation.prototype.vars;


/**
 * @export
 * @type {com.greensock.core.SimpleTimeline}
 */
com.greensock.core.Animation.prototype.timeline;


/**
 * @export
 * @type {*}
 */
com.greensock.core.Animation.prototype.data;


/**
 * Begins playing forward, optionally from a specific time (by default playback begins from
 * wherever the playhead currently is). This also ensures that the instance is neither paused 
 * nor reversed.
 * 
 * <p>If you define a "from" time (the first parameter, which could also be a label for TimelineLite
 * or TimelineMax instances), the playhead moves there immediately and if there are any 
 * events/callbacks inbetween where the playhead was and the new time, they will not be triggered 
 * because by default <code>suppressEvents</code> (the 2nd parameter) is <code>true</code>. 
 * Think of it like picking the needle up on a record player and moving it to a new position 
 * before placing it back on the record. If, however, you do not want the events/callbacks suppressed 
 * during that initial move, simply set the <code>suppressEvents</code> parameter to <code>false</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 * 
 * @asparam from The time (or label for TimelineLite/TimelineMax instances) from which the animation should begin playing (if none is defined, it will begin playing from wherever the playhead currently is).
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>from</code> parameter.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {*=} from
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.play = function(from, suppressEvents) {
  from = typeof from !== 'undefined' ? from : null;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  if (from != null) {
    this.seek(from, suppressEvents);
  }
  this.reversed(false);
  return this.paused(false);
};


/**
 * Pauses the instance, optionally jumping to a specific time. 
 * 
 * <p>If you define a time to jump to (the first parameter, which could also be a label for TimelineLite
 * or TimelineMax instances), the playhead moves there immediately and if there are any 
 * events/callbacks inbetween where the playhead was and the new time, they will not be triggered 
 * because by default <code>suppressEvents</code> (the 2nd parameter) is <code>true</code>. 
 * Think of it like picking the needle up on a record player and moving it to a new position 
 * before placing it back on the record. If, however, you do not want the events/callbacks suppressed 
 * during that initial move, simply set the <code>suppressEvents</code> parameter to <code>false</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 * 
 * @asparam atTime The time (or label for TimelineLite/TimelineMax instances) that the instance should jump to before pausing (if none is defined, it will pause wherever the playhead is currently located).
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>atTime</code> parameter.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {*=} atTime
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.pause = function(atTime, suppressEvents) {
  atTime = typeof atTime !== 'undefined' ? atTime : null;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  if (atTime != null) {
    this.seek(atTime, suppressEvents);
  }
  return this.paused(true);
};


/**
 * Resumes playing without altering direction (forward or reversed), optionally jumping to a specific time first. 
 * 
 * <p>If you define a time to jump to (the first parameter, which could also be a label for TimelineLite
 * or TimelineMax instances), the playhead moves there immediately and if there are any 
 * events/callbacks inbetween where the playhead was and the new time, they will not be triggered 
 * because by default <code>suppressEvents</code> (the 2nd parameter) is <code>true</code>. 
 * Think of it like picking the needle up on a record player and moving it to a new position 
 * before placing it back on the record. If, however, you do not want the events/callbacks suppressed 
 * during that initial move, simply set the <code>suppressEvents</code> parameter to <code>false</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 * 
 * @asparam from The time (or label for TimelineLite/TimelineMax instances) that the instance should jump to before resuming playback (if none is defined, it will resume wherever the playhead is currently located).
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>from</code> parameter.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {*=} from
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.resume = function(from, suppressEvents) {
  from = typeof from !== 'undefined' ? from : null;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  if (from != null) {
    this.seek(from, suppressEvents);
  }
  return this.paused(false);
};


/**
 * Jumps to a specific time without affecting whether or not the instance is paused or reversed.
 * 
 * <p>If there are any events/callbacks inbetween where the playhead was and the new time, 
 * they will not be triggered because by default <code>suppressEvents</code> (the 2nd parameter) 
 * is <code>true</code>. Think of it like picking the needle up on a record player and moving it 
 * to a new position before placing it back on the record. If, however, you do not want the 
 * events/callbacks suppressed during that initial move, simply set the <code>suppressEvents</code> 
 * parameter to <code>false</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * @asparam time The time (or label for TimelineLite/TimelineMax instances) to go to.
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>time</code> parameter.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {*} time
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.seek = function(time, suppressEvents) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  return this.totalTime(Number(time), suppressEvents);
};


/**
 * Restarts and begins playing forward from the beginning.
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 * 
 * @asparam includeDelay Determines whether or not the delay (if any) is honored when restarting. For example, if a tween has a delay of 1 second, like <code>new TweenLite(mc, 2, {x:100, delay:1});</code> and then later <code>restart()</code> is called, it will begin immediately, but <code>restart(true)</code> will cause the delay to be honored so that it won't begin for another 1 second.
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>time</code> parameter. 
 * @asreturn self (makes chaining easier)
 * @export
 * @param {boolean=} includeDelay
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.restart = function(includeDelay, suppressEvents) {
  includeDelay = typeof includeDelay !== 'undefined' ? includeDelay : false;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  this.reversed(false);
  this.paused(false);
  return this.totalTime((includeDelay ? -this._delay : 0), suppressEvents, true);
};


/**
 * Reverses playback so that all aspects of the animation are oriented backwards including, for example,
 * a tween's ease. This will cause the instance's <code>time</code> and <code>totalTime</code> to move 
 * back towards zero as well. You can optionally define a specific time to jump to before reversing
 * (by default it begins playing in reverse from wherever the playhead currently is). 
 * Calling <code>reverse()</code> also ensures that the instance is neither paused nor reversed.
 * 
 * <p>To jump to the very end of the animation and play in reverse from there, use 0 as the 
 * "from" parameter, like <code>reverse(0)</code>.</p>
 * 
 * <p>To check whether or not the instance is reversed, use the <code>reversed()</code> method, like
 * <code>if (myAnimation.reversed()) {...}</code></p>
 * 
 * <p>If you define a "from" time (the first parameter, which could also be a label for TimelineLite
 * or TimelineMax instances), the playhead moves there immediately and if there are any 
 * events/callbacks inbetween where the playhead was and the new time, they will not be triggered 
 * because by default <code>suppressEvents</code> (the 2nd parameter) is <code>true</code>. 
 * Think of it like picking the needle up on a record player and moving it to a new position 
 * before placing it back on the record. If, however, you do not want the events/callbacks suppressed 
 * during that initial move, simply set the <code>suppressEvents</code> parameter to <code>false</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 * 
 * @asparam from The time (or label for TimelineLite/TimelineMax instances) from which the animation should begin playing in reverse (if none is defined, it will begin playing from wherever the playhead currently is). To begin at the very end of the animation, use <code>0</code>. Negative numbers are relative to the end of the animation, so -1 would be 1 second from the end.
 * @asparam suppressEvents If <code>true</code> (the default), no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>from</code> parameter.
 * @asreturn self (makes chaining easier)
 * @export
 * @param {*=} from
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.reverse = function(from, suppressEvents) {
  from = typeof from !== 'undefined' ? from : null;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : true;
  if (from != null) {
    this.seek((from || this.totalDuration()), suppressEvents);
  }
  this.reversed(true);
  return this.paused(false);
};


/**
 * @asprivate
 * Renders the animation at a particular time (or frame number for frames-based tweens). 
 * The time is based simply on the overall duration. For example, if an animations's duration
 * is 3, render(1.5) would render it as halfway finished.
 * 
 * @asparam time time (or frame number for frames-based animations) to render. If a negative value is used, it will act like 0. If the value exceeds the <code>totalDuration</code>, it will act like the <code>totalDuration</code>.
 * @asparam suppressEvents If true, no events or callbacks will be triggered for this render (like onComplete, onUpdate, onReverseComplete, etc.)
 * @asparam force Normally the animation will skip rendering if the time matches the _totalTime (to improve performance), but if force is true, it forces a render. This is primarily used internally for tweens with durations of zero in TimelineLite/Max instances.
 * @export
 * @param {number} time
 * @param {boolean=} suppressEvents
 * @param {boolean=} force
 */
com.greensock.core.Animation.prototype.render = function(time, suppressEvents, force) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  force = typeof force !== 'undefined' ? force : false;
};


/** 
 * Clears any initialization data (like starting/ending values in tweens) which can be useful if, for example, 
 * you want to restart a tween without reverting to any previously recorded starting values. When you <code>invalidate()</code> 
 * an animation, it will be re-initialized the next time it renders and its <code>vars</code> object will be re-parsed. 
 * The timing of the animation (duration, startTime, delay) will not be affected.
 * 
 * <p>Another example would be if you have a <code>TweenMax(mc, 1, {x:100, y:100})</code> that ran when mc.x and mc.y 
 * were initially at 0, but now mc.x and mc.y are 200 and you want them tween to 100 again, you could simply 
 * <code>invalidate()</code> the tween and <code>restart()</code> it. Without invalidating first, restarting it 
 * would cause the values jump back to 0 immediately (where they started when the tween originally began). 
 * When you invalidate a TimelineLite/TimelineMax, it automatically invalidates all of its children.</p>
 * @asreturn self (makes chaining easier)
 * @export
 * @return {*}
 */
com.greensock.core.Animation.prototype.invalidate = function() {
  return this;
};


/** 
 * Indicates whether or not the animation is currently active (meaning the virtual playhead is actively moving across 
 * this instance's time span and it is not paused, nor are any of its ancestor timelines).
 * So for example, if a tween is in the middle of tweening, it's active, but after it is finished (or before 
 * it begins), it is <strong>not</strong> active. If it is paused or if it is placed inside of a timeline that's paused
 * (or if any of its ancestor timelines are paused), <code>isActive()</code> will return <code>false</code>. If the
 * playhead is directly on top of the animation's start time (even if it hasn't rendered quite yet), that counts
 * as "active".
 * 
 * <p>You may also check the <code>progress()</code> or <code>totalProgress()</code>, but those don't take into consideration
 * the paused state or the position of the parent timeline's playhead.</p>
 * 
 * @see #progress()
 * @see #totalProgress()
 * @export
 * @return {boolean}
 */
com.greensock.core.Animation.prototype.isActive = function() {
  var /** @type {com.greensock.core.SimpleTimeline} */ tl = this._timeline, /** @type {number} */ rawTime;
  return ((tl == null) || (!this._gc && !this._paused && tl.isActive() && (rawTime = tl.rawTime()) >= this._startTime && rawTime < this._startTime + this.totalDuration() / this._timeScale));
};


/**
 * @asprivate
 * If an animation is enabled, it is eligible to be rendered (unless it is paused). Disabling it
 * essentially removes it from its parent timeline and stops protecting it from garbage collection.
 * 
 * @asparam enabled Enabled state of the animation
 * @asparam ignoreTimeline By default, the tween/timeline will remove itself from its parent timeline when it is disabled and add itself when it is enabled, but this parameter allows you to skip that behavior.
 * @asreturn Boolean value indicating whether or not important properties may have changed when the animation was enabled/disabled. For example, when a MotionBlurPlugin is disabled, it swaps out a BitmapData for the target and may alter the opacity. We need to know this in order to determine whether or not a new tween that is overwriting this one should be re-initialized with the changed properties. 
 * @export
 * @param {boolean} enabled
 * @param {boolean=} ignoreTimeline
 * @return {boolean}
 */
com.greensock.core.Animation.prototype._enabled = function(enabled, ignoreTimeline) {
  ignoreTimeline = typeof ignoreTimeline !== 'undefined' ? ignoreTimeline : false;
  this._gc = !enabled;
  this._active = Boolean(enabled && !this._paused && this._totalTime > 0 && this._totalTime < this._totalDuration);
  if (!ignoreTimeline) {
    if (enabled && this.timeline == null) {
      this._timeline.add(this, this._startTime - this._delay);
    } else if (!enabled && this.timeline != null) {
      this._timeline._remove(this, true);
    }
  }
  return false;
};


/** @asprivate Same as <code>kill()</code> except that it returns a Boolean that indicates whether or not important properties may have changed when the animation was killed. For example, when a MotionBlurPlugin is disabled, it swaps out a BitmapData for the target and may alter the opacity. We need to know this in order to determine whether or not a new tween that is overwriting this one should be re-initialized with the changed properties. *
 * @export
 * @param {Object=} vars
 * @param {Object=} target
 * @return {boolean}
 */
com.greensock.core.Animation.prototype._kill = function(vars, target) {
  vars = typeof vars !== 'undefined' ? vars : null;
  target = typeof target !== 'undefined' ? target : null;
  return this._enabled(false, false);
};


/**
 * Kills the animation entirely or in part depending on the parameters. Simply calling <code>kill()</code>
 * (omitting the parameters) will immediately stop the animation and release it for garbage collection. 
 * To kill only particular tweening properties of the animation, use the first parameter which should
 * be a generic object with enumerable properties corresponding to those that should be killed,
 * like <code>{x:true, y:true}</code>. The second parameter allows you to define a target 
 * (or array of targets) to affect. 
 * 
 * <p>Note: the values assigned to each property of the <code>vars</code> parameter object don't 
 * matter - the sole purpose of the object is for iteration over the named properties. In other 
 * words, <code>{x:true, y:true}</code> would produce the same results as <code>{x:false, y:false}</code>.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 * 
 * @asparam vars To kill only specific properties, use a generic object containing enumerable properties corresponding to the ones that should be killed, like <code>{x:true, y:true}</code>. The values assigned to each property of the object don't matter - the sole purpose of the object is for iteration over the named properties (in this case, <code>x</code> and <code>y</code>). If no object (or <code>null</code>) is defined, <strong>ALL</strong> properties will be killed.
 * @asparam target To kill only aspects of the animation related to a particular target (or targets), reference it here. For example, to kill only parts having to do with <code>myObject</code>, do <code>kill(null, myObject)</code> or to kill only parts having to do with <code>myObject1</code> and <code>myObject2</code>, do <code>kill(null, [myObject1, myObject2])</code>. If no target is defined, <strong>ALL</strong> targets will be affected. 
 * @asreturn self (makes chaining easier)
 * @export
 * @param {Object=} vars
 * @param {Object=} target
 * @return {*}
 */
com.greensock.core.Animation.prototype.kill = function(vars, target) {
  vars = typeof vars !== 'undefined' ? vars : null;
  target = typeof target !== 'undefined' ? target : null;
  this._kill(vars, target);
  return this;
};


/**
 * @asprivate
 * Sets the <code>_dirty</code> property of all anscestor timelines (and optionally this instance too). Setting
 * the <code>_dirty</code> property to <code>true</code> forces any necessary recalculation of its _duration and 
 * _totalDuration properties and sorts the affected timelines' children animations so that they're in the proper order 
 * next time the <code>duration</code> or <code>totalDuration</code> is requested. We don't just recalculate them 
 * immediately because it can be much faster to do it this way.
 * 
 * @asparam includeSelf indicates whether or not this tween's <code>_dirty</code> property should be affected.
 * @asreturn self (makes chaining easier)
 * @protected
 * @param {boolean} includeSelf
 * @return {*}
 */
com.greensock.core.Animation.prototype._uncache = function(includeSelf) {
  var /** @type {com.greensock.core.Animation} */ tween = includeSelf ? this : this.timeline;
  while (tween) {
    tween._dirty = true;
    tween = tween.timeline;
  }
  return this;
};


/** @asprivate This method gets called on every frame and is responsible for rendering/updating the root timelines. If you want to unhook the engine from its ticker, you could do <code>Animation.ticker.removeEventListener("enterFrame", _updateRoot)</code> and then call it yourself whenever you want to update. *
 * @export
 * @param {flash.events.Event=} event
 */
com.greensock.core.Animation._updateRoot = function(event) {
  event = typeof event !== 'undefined' ? event : null;
  com.greensock.core.Animation._rootFrame++;
  com.greensock.core.Animation._rootTimeline.render((flash.utils.getTimer() / 1000 - com.greensock.core.Animation._rootTimeline._startTime) * com.greensock.core.Animation._rootTimeline._timeScale, false, false);
  com.greensock.core.Animation._rootFramesTimeline.render((com.greensock.core.Animation._rootFrame - com.greensock.core.Animation._rootFramesTimeline._startTime) * com.greensock.core.Animation._rootFramesTimeline._timeScale, false, false);
  com.greensock.core.Animation.ticker.dispatchEvent(com.greensock.core.Animation._tickEvent);
};


/** @asprivate *
 * @protected
 * @param {Array} params
 * @return {Array}
 */
com.greensock.core.Animation.prototype._swapSelfInParams = function(params) {
  var /** @type {number} */ i = params.length, /** @type {Array} */ copy = params.concat();
  while (--i > -1) {
    if (params[i] === "{self}") {
      copy[i] = this;
    }
  }
  return copy;
};


/**
 * Gets or sets an event callback like <code>"onComplete", "onUpdate", "onStart", "onReverseComplete"</code>
 * or <code>"onRepeat"</code> (<code>onRepeat</code> only applies to TweenMax or TimelineMax instances)
 * along with any parameters that should be passed to that callback. This is the same as defining
 * the values directly in the constructor's <code>vars</code> parameter initially, so the following 
 * two lines are functionally equivalent:
 * 
 * <listing version="3.0">
 
 
 
 
 * <p>The benefit of using <code>eventCallback()</code> is that it allows you to set callbacks 
 * even after the animation instance has been created and it also allows you to inspect the
 * callback references or even delete them on-the-fly (use <code>null</code> to delete the 
 * event callback).</p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * <p><strong>IMPORTANT:</strong>Animation instances can only have one callback associated with each
 * event type (one <code>onComplete</code>, one <code>onUpdate</code>, one <code>onStart</code>, etc.). 
 * So setting a new value will overwrite the old one. All of the values populate the <code>vars</code>
 * object too which was originally passed into the constructor (think of that like a storage place for 
 * configuration data).</p>
 * 
 * <p>This method serves as both a getter and setter. Omitting all but the first parameter returns 
 * the current value (getter), whereas defining more than the first parameter sets the value (setter) 
 * and returns the instance itself for easier chaining, like 
 * <code>myAnimation.eventCallback("onComplete", completeHandler).eventCallback("onUpdate", updateHandler, ["param1","{self}"]).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * <p><strong>JavaScript and AS2 note:</strong> - Due to the way JavaScript and AS2 don't 
 * maintain scope (what "<code>this</code>" refers to, or the context) in function calls, 
 * it can be useful to define the scope specifically. Therefore, in the JavaScript and AS2 
 * versions accept an extra (4th) parameter for <code>scope</code>.</p>
 * 
 * @asparam type The type of event callback, like <code>"onComplete", "onUpdate", "onStart"</code> or <code>"onRepeat"</code>. This is case-sensitive.
 * @asparam callback The function that should be called when the event occurs.
 * @asparam params An array of parameters to pass the callback. Use <code>"{self}"</code> to refer to the animation instance itself. Example: <code>["param1","{self}"]</code>
 * @asreturn Omitting the all but the first parameter returns the current value (getter), whereas defining more than the first parameter sets the callback (setter) and returns the instance itself for easier chaining.
 * @export
 * @param {string} type
 * @param {Function=} callback
 * @param {Array=} params
 * @return {*}
 */
com.greensock.core.Animation.prototype.eventCallback = function(type, callback, params) {
  callback = typeof callback !== 'undefined' ? callback : null;
  params = typeof params !== 'undefined' ? params : null;
  if (type == null) {
    return null;
  } else if (type.substr(0, 2) == "on") {
    if (arguments.length == 1) {
      return this.vars[type];
    }
    if (callback == null) {
      delete this.vars[type];
    } else {
      this.vars[type] = callback;
      this.vars[type + "Params"] = (org.apache.royale.utils.Language.is(params, Array) && params.join("").indexOf("{self}") !== -1) ? this._swapSelfInParams(params) : params;
    }
    if (type == "onUpdate") {
      this._onUpdate = callback;
    }
  }
  return this;
};


/** 
 * Gets or sets the animation's initial delay which is the length of time in seconds 
 * (or frames for frames-based tweens) before the animation should begin. 
 * A tween's starting values are not recorded until after the delay has expired (except in 
 * <code>from()</code> tweens which render immediately by default unless <code>immediateRender:false</code> 
 * is set in the <code>vars</code> parameter). An animation's <code>delay</code> is unaffected
 * by its <code>timeScale</code>, so if you were to change <code>timeScale</code> from 1 to 10, 
 * for example, it wouldn't cause the delay to grow tenfold.
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.delay(2).timeScale(0.5).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @export
 * @param {number=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.delay = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  if (!arguments.length) {
    return this._delay;
  }
  if (this._timeline.smoothChildTiming) {
    this.startTime(this._startTime + value - this._delay);
  }
  this._delay = value;
  return this;
};


/**
 * Gets or sets the animation's duration, <strong>not</strong> including any repeats or repeatDelays 
 * (which are only available in TweenMax and TimelineMax). For example, if a TweenMax instance has 
 * a <code>duration</code> of 2 and a <code>repeat</code> of 3, its <code>totalDuration</code> 
 * would be 8 (one standard play plus 3 repeats equals 4 total cycles).
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.duration(2).delay(0.5).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #totalDuration()
 * @see #timeScale()
 * @export
 * @param {number=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.duration = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  if (!arguments.length) {
    this._dirty = false;
    return this._duration;
  }
  this._duration = this._totalDuration = value;
  this._uncache(true);
  if (this._timeline.smoothChildTiming)
    if (this._time > 0)
      if (this._time < this._duration)
        if (value != 0) {
          this.totalTime(this._totalTime * (value / this._duration), true);
        }
  return this;
};


/**
 * Gets or sets the animation's <strong>total</strong> duration including 
 * any repeats or repeatDelays (which are only available in TweenMax and TimelineMax). 
 * For example, if a TweenMax instance has a <code>duration</code> of 2 and a repeat of 3, 
 * its <code>totalDuration</code> would be 8 (one standard play plus 3 repeats equals 4 total cycles).
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.totalDuration(2).delay(0.5).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #duration()
 * @see #timeScale()
 * @export
 * @param {number=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.totalDuration = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  this._dirty = false;
  return (!arguments.length) ? this._totalDuration : this.duration(value);
};


/**
 * Gets or sets the local position of the playhead (essentially the current time), 
 * described in seconds (or frames for frames-based animations) which
 * will never be less than 0 or greater than the animation's <code>duration</code>. 
 * For example, if the <code>duration</code> is 10 and you were to watch the 
 * <code>time</code> during the course of the animation, you'd see it go from 0
 * at the beginning to 10 at the end. Setting <code>time</code> to 5 would cause the 
 * animation to jump to its midway point (because it's half of the duration). 
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining.</p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining. Negative values will be interpreted from the <strong>END</strong> of the animation.
 * @asparam suppressEvents If <code>true</code>, no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>value</code> parameter.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #seek()
 * @see #play()
 * @see #reverse()
 * @see #pause()
 * @see #totalTime()
 * @export
 * @param {number=} value
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.time = function(value, suppressEvents) {
  value = typeof value !== 'undefined' ? value : NaN;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  if (!arguments.length) {
    return this._time;
  }
  if (this._dirty) {
    this.totalDuration();
  }
  if (value > this._duration) {
    value = this._duration;
  }
  return this.totalTime(value, suppressEvents);
};


/**
 * Gets or sets the position of the playhead according to the <code>totalDuration</code>
 * which <strong>includes any repeats and repeatDelays</strong> (only available 
 * in TweenMax and TimelineMax). For example, if a TweenMax instance has a 
 * <code>duration</code> of 2 and a <code>repeat</code> of 3, <code>totalTime</code> 
 * will go from 0 to 8 during the course of the tween (plays once then repeats 3 times, 
 * making 4 total cycles) whereas <code>time</code> will go from 0 to 2 a total of 4 times. 
 * If you added a <code>repeatDelay</code> of 1, that would make the <code>totalTime</code>
 * go from 0 to 11 over the course of the tween. 
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining.</p>
 * 
 * <p><code>totalTime</code> will never exceed the <code>totalDuration</code>, nor will it be 
 * less than 0 (values will be clipped appropriately). Negative values will be interpreted from 
 * the <strong>END</strong> of the animation. For example, -2 would be 2 seconds before the end. If the 
 * animation's <code>totalDuration</code> is 6 and you do <code>myAnimation.totalTime(-2)</code>, 
 * it will jump to a <code>totalTime</code> of 4.</p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * @asparam time Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining. Negative values will be interpreted from the <strong>END</strong> of the animation.
 * @asparam suppressEvents If <code>true</code>, no events or callbacks will be triggered when the playhead moves to the new position defined in the <code>time</code> parameter.
 * @asparam uncapped By default, the <code>time</code> will be capped at <code>totalDuration</code> and if a negative number is used, it will be measured from the END of the animation, but if <code>uncapped</code> is <code>true</code>, the <code>time</code> won't be adjusted at all (negatives will be allowed, as will values that exceed totalDuration).
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #time()
 * @see #seek()
 * @see #play()
 * @see #reverse()
 * @see #pause()
 * @export
 * @param {number=} time
 * @param {boolean=} suppressEvents
 * @param {boolean=} uncapped
 * @return {*}
 */
com.greensock.core.Animation.prototype.totalTime = function(time, suppressEvents, uncapped) {
  time = typeof time !== 'undefined' ? time : NaN;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  uncapped = typeof uncapped !== 'undefined' ? uncapped : false;
  if (!arguments.length) {
    return this._totalTime;
  }
  if (this._timeline) {
    if (time < 0 && !uncapped) {
      time += Number(this.totalDuration());
    }
    if (this._timeline.smoothChildTiming) {
      if (this._dirty) {
        this.totalDuration();
      }
      if (time > this._totalDuration && !uncapped) {
        time = this._totalDuration;
      }
      var /** @type {com.greensock.core.SimpleTimeline} */ tl = this._timeline;
      this._startTime = (this._paused ? this._pauseTime : tl._time) - ((!this._reversed ? time : this._totalDuration - time) / this._timeScale);
      if (!this._timeline._dirty) {
        this._uncache(false);
      }
      if (tl._timeline != null) {
        while (tl._timeline) {
          if (tl._timeline._time !== (tl._startTime + tl._totalTime) / tl._timeScale) {
            tl.totalTime(tl._totalTime, true);
          }
          tl = tl._timeline;
        }
      }
    }
    if (this._gc) {
      this._enabled(true, false);
    }
    if (this._totalTime != time || this._duration === 0) {
      this.render(time, suppressEvents, false);
    }
  }
  return this;
};


/** 
 * Gets or sets the animations's progress which is a value between 0 and 1 indicating the position 
 * of the virtual playhead (<strong>excluding</strong> repeats) where 0 is at the beginning, 0.5 is at the halfway point, 
 * and 1 is at the end (complete). If the animation has a non-zero <code>repeat</code> defined (only available in TweenMax and TimelineMax), 
 * <code>progress()</code> and <code>totalProgress()</code> will be different because <code>progress()</code> doesn't include the 
 * <code>repeat</code> or <code>repeatDelay</code> whereas <code>totalProgress()</code> does. For example, if a TimelineMax instance 
 * is set to repeat once, at the end of the first cycle <code>totalProgress()</code> would only be 0.5 
 * whereas <code>progress()</code> would be 1. If you watched both properties over the course of the entire 
 * animation, you'd see <code>progress()</code> go from 0 to 1 twice (once for each cycle) in the 
 * same time it takes the <code>totalProgress()</code> to go from 0 to 1 once.
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.progress(0.5).play();</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asparam suppressEvents If <code>true</code>, no events or callbacks will be triggered when the playhead moves to the new position.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #seek()
 * @see #time()
 * @see #totalTime()
 * @see #totalProgress()
 * @export
 * @param {number=} value
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.progress = function(value, suppressEvents) {
  value = typeof value !== 'undefined' ? value : NaN;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
};


/** 
 * Gets or sets the animation's total progress which is a value between 0 and 1 indicating the position 
 * of the virtual playhead (<strong>including</strong> repeats) where 0 is at the beginning, 0.5 is 
 * at the halfway point, and 1 is at the end (complete). If the animation has a non-zero <code>repeat</code> defined  (only available in TweenMax and TimelineMax), 
 * <code>progress()</code> and <code>totalProgress()</code> will be different because <code>progress()</code> 
 * doesn't include the <code>repeat</code> or <code>repeatDelay</code> whereas <code>totalProgress()</code> does. For example, 
 * if a TimelineMax instance is set to repeat once, at the end of the first cycle <code>totalProgress()</code> 
 * would only be 0.5 whereas <code>progress</code> would be 1. If you watched both properties over the 
 * course of the entire animation, you'd see <code>progress</code> go from 0 to 1 twice (once for 
 * each cycle) in the same time it takes the <code>totalProgress()</code> to go from 0 to 1 once.
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.totalProgress(0.5).play();</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asparam suppressEvents If <code>true</code>, no events or callbacks will be triggered when the playhead moves to the new position.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #progress()
 * @see #seek()
 * @see #time()
 * @see #totalTime()
 * @export
 * @param {number=} value
 * @param {boolean=} suppressEvents
 * @return {*}
 */
com.greensock.core.Animation.prototype.totalProgress = function(value, suppressEvents) {
  value = typeof value !== 'undefined' ? value : NaN;
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  return (!arguments.length) ? this._time / this.duration() : this.totalTime(this.duration() * value, suppressEvents);
};


/** 
 * Gets or sets the time at which the animation begins on its parent timeline (after any <code>delay</code>
 * that was defined). For example, if a tween starts at exactly 3 seconds into the timeline 
 * on which it is placed, the tween's <code>startTime</code> would be 3. 
 * 
 * <p>The <code>startTime</code> may be automatically adjusted to make the timing appear
 * seamless if the parent timeline's <code>smoothChildTiming</code> property is <code>true</code> 
 * and a timing-dependent change is made on-the-fly, like <code>reverse()</code> is called or 
 * <code>timeScale()</code> is changed, etc. See the documentation for the <code>smoothChildTiming</code> 
 * property of timelines for more details.</p>
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining.</p>
 * 
 * <listing version="3.0">
 
 
 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @export
 * @param {number=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.startTime = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  if (!arguments.length) {
    return this._startTime;
  }
  if (value != this._startTime) {
    this._startTime = value;
    if (this.timeline)
      if (this.timeline._sortChildren) {
        this.timeline.add(this, value - this._delay);
      }
  }
  return this;
};


/** 
 * Factor that's used to scale time in the animation where 1 = normal speed (the default),
 * 0.5 = half speed, 2 = double speed, etc. For example, if an animation's <code>duration</code> 
 * is 2 but its <code>timeScale</code> is 0.5, it will take 4 seconds to finish. If you nest that 
 * animation in a timeline whose <code>timeScale</code> is 0.5 as well, it would take 8 seconds 
 * to finish. You can even tween the <code>timeScale</code> to gradually slow it down or speed it up.
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.timeScale(2).play(1);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 * 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #duration()
 * @export
 * @param {number=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.timeScale = function(value) {
  value = typeof value !== 'undefined' ? value : NaN;
  if (!arguments.length) {
    return this._timeScale;
  }
  value = value || 0.000001;
  if (this._timeline && this._timeline.smoothChildTiming) {
    var /** @type {number} */ t = (this._pauseTime || this._pauseTime == 0) ? this._pauseTime : this._timeline._totalTime;
    this._startTime = t - ((t - this._startTime) * this._timeScale / value);
  }
  this._timeScale = value;
  return this._uncache(false);
};


/** 
 * Gets or sets the animation's reversed state which indicates whether or not the animation 
 * should be played backwards. This value is not affected by <code>yoyo</code> repeats 
 * (TweenMax and TimelineMax only) and it does not take into account the reversed state of 
 * anscestor timelines. So for example, a tween that is not reversed might appear reversed 
 * if its parent timeline (or any ancenstor timeline) is reversed. 
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining.</p>
 * 
 * <listing version="3.0">
 
 
 
 
 * 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #reverse()
 * @see #play()
 * @export
 * @param {boolean=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.reversed = function(value) {
  value = typeof value !== 'undefined' ? value : false;
  if (!arguments.length) {
    return this._reversed;
  }
  if (value != this._reversed) {
    this._reversed = value;
    this.totalTime(((this._timeline && !this._timeline.smoothChildTiming) ? this.totalDuration() - this._totalTime : this._totalTime), true);
  }
  return this;
};


/** 
 * Gets or sets the animation's paused state which indicates whether or not the animation 
 * is currently paused. This does not take into account anscestor timelines. So for example, 
 * a tween that is not paused might appear paused if its parent timeline (or any ancenstor 
 * timeline) is paused. Pausing an animation doesn't remove it from its parent timeline, 
 * but it does cause it not to be factored into the parent timeline's 
 * <code>duration/totalDuration</code>. When an animation completes, it does 
 * <strong>NOT</strong> alter its paused state.
 * 
 * <p>In most cases, it is easiest to use the <code>pause()</code> method to pause
 * the animation, and <code>resume()</code> to resume it. But to check the current
 * state, you must use the <code>paused()</code> method. It can also be useful for 
 * toggling like <code>myAnimation.paused( !myAnimation.paused() );</code></p>
 * 
 * <p>You can set the <code>paused</code> state initially by passing <code>paused:true</code>
 * in the <code>vars</code> parameter.</p>
 * 
 * <p>This method serves as both a getter and setter. Omitting the parameter returns the current 
 * value (getter), whereas defining the parameter sets the value (setter) and returns the instance 
 * itself for easier chaining, like <code>myAnimation.paused(true).delay(2).timeScale(0.5);</code></p>
 * 
 * <listing version="3.0">
 
 
 
 
 * @asparam value Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * @asreturn Omitting the parameter returns the current value (getter), whereas defining the parameter sets the value (setter) and returns the instance itself for easier chaining.
 * 
 * @see #pause()
 * @see #resume()
 * @see #play()
 * @export
 * @param {boolean=} value
 * @return {*}
 */
com.greensock.core.Animation.prototype.paused = function(value) {
  value = typeof value !== 'undefined' ? value : false;
  if (!arguments.length) {
    return this._paused;
  }
  if (value != this._paused)
    if (this._timeline) {
      var /** @type {number} */ raw = this._timeline.rawTime(), /** @type {number} */ elapsed = raw - this._pauseTime;
      if (!value && this._timeline.smoothChildTiming) {
        this._startTime += elapsed;
        this._uncache(false);
      }
      this._pauseTime = value ? raw : NaN;
      this._paused = value;
      this._active = (!value && this._totalTime > 0 && this._totalTime < this._totalDuration);
      if (!value && elapsed != 0 && this._initted && this.duration() !== 0) {
        this.render((this._timeline.smoothChildTiming ? this._totalTime : (raw - this._startTime) / this._timeScale), true, true);
      }
    }
  if (this._gc && !value) {
    this._enabled(true, false);
  }
  return this;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
com.greensock.core.Animation.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Animation', qName: 'com.greensock.core.Animation', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
com.greensock.core.Animation.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        '|ticker': { type: 'flash.display.Shape'},
        '|_rootTimeline': { type: 'com.greensock.core.SimpleTimeline'},
        '|_rootFramesTimeline': { type: 'com.greensock.core.SimpleTimeline'},
        '_delay': { type: 'Number'},
        '_rawPrevTime': { type: 'Number'},
        '_active': { type: 'Boolean'},
        '_gc': { type: 'Boolean'},
        '_initted': { type: 'Boolean'},
        '_startTime': { type: 'Number'},
        '_time': { type: 'Number'},
        '_totalTime': { type: 'Number'},
        '_duration': { type: 'Number'},
        '_totalDuration': { type: 'Number'},
        '_pauseTime': { type: 'Number'},
        '_timeScale': { type: 'Number'},
        '_reversed': { type: 'Boolean'},
        '_timeline': { type: 'com.greensock.core.SimpleTimeline'},
        '_dirty': { type: 'Boolean'},
        '_paused': { type: 'Boolean'},
        '_next': { type: 'com.greensock.core.Animation'},
        '_prev': { type: 'com.greensock.core.Animation'},
        'vars': { type: 'Object'},
        'timeline': { type: 'com.greensock.core.SimpleTimeline'},
        'data': { type: '*'}
      };
    },
    accessors: function () {return {};},
    methods: function () {
      return {
        'Animation': { type: '', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true },{ index: 2, type: 'Object', optional: true } ]; }},
        'play': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: '*', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'pause': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: '*', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'resume': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: '*', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'seek': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'restart': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Boolean', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'reverse': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: '*', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'render': { type: 'void', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Boolean', optional: true } ]; }},
        'invalidate': { type: '*', declaredBy: 'com.greensock.core.Animation'},
        'isActive': { type: 'Boolean', declaredBy: 'com.greensock.core.Animation'},
        '_enabled': { type: 'Boolean', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Boolean', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        '_kill': { type: 'Boolean', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Object', optional: true },{ index: 2, type: 'Object', optional: true } ]; }},
        'kill': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Object', optional: true },{ index: 2, type: 'Object', optional: true } ]; }},
        '|_updateRoot': { type: 'void', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'flash.events.Event', optional: true } ]; }},
        'eventCallback': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'String', optional: false },{ index: 2, type: 'Function', optional: true },{ index: 3, type: 'Array', optional: true } ]; }},
        'delay': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'duration': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'totalDuration': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'time': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'totalTime': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Boolean', optional: true } ]; }},
        'progress': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'totalProgress': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'startTime': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'timeScale': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Number', optional: true } ]; }},
        'reversed': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Boolean', optional: true } ]; }},
        'paused': { type: '*', declaredBy: 'com.greensock.core.Animation', parameters: function () { return [  { index: 1, type: 'Boolean', optional: true } ]; }}
      };
    }
  };
};
