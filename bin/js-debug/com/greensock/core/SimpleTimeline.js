/**
 * Generated by Apache Royale Compiler from com\greensock\core\SimpleTimeline.as
 * com.greensock.core.SimpleTimeline
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('com.greensock.core.SimpleTimeline');
/* Royale Dependency List: org.apache.royale.utils.Language,XML*/

goog.require('com.greensock.core.Animation');



/**
 * Constructor
 * 
 * @asparam vars Object containing configuration variables like onComplete, onUpdate, onStart, data, etc.
 * @constructor
 * @extends {com.greensock.core.Animation}
 * @param {Object=} vars
 */
com.greensock.core.SimpleTimeline = function(vars) {
  vars = typeof vars !== 'undefined' ? vars : null;
  com.greensock.core.SimpleTimeline.base(this, 'constructor', 0, vars);
  this.autoRemoveChildren = this.smoothChildTiming = true;
};
goog.inherits(com.greensock.core.SimpleTimeline, com.greensock.core.Animation);


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('com.greensock.core.SimpleTimeline', com.greensock.core.SimpleTimeline);


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.SimpleTimeline.prototype.autoRemoveChildren;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.SimpleTimeline.prototype.smoothChildTiming;


/**
 * @export
 * @type {boolean}
 */
com.greensock.core.SimpleTimeline.prototype._sortChildren;


/**
 * @export
 * @type {com.greensock.core.Animation}
 */
com.greensock.core.SimpleTimeline.prototype._first;


/**
 * @export
 * @type {com.greensock.core.Animation}
 */
com.greensock.core.SimpleTimeline.prototype._last;


/**
 * @asprivate
 * <strong>[Deprecated in favor of add()]</strong>
 * Inserts a TweenLite, TweenMax, TimelineLite, or TimelineMax instance into the timeline at a specific time. 
 * In classes like TimelineLite and TimelineMax that override this method, it allows things like callbacks,
 * labels, and arrays of tweens/timelines/callbacks/labels to be inserted too. They also allow the time to
 * be defined in terms of either a numeric time or a label (String).
 * 
 * @asparam child TweenLite, TweenMax, TimelineLite, or TimelineMax instance to insert
 * @asparam position The time in seconds (or frames for frames-based timelines) at which the tween/timeline should be inserted. For example, <code>myTimeline.insert(myTween, 3)</code> would insert myTween 3 seconds into the timeline.
 * @asreturn this timeline instance (useful for chaining like <code>myTimeline.insert(...).insert(...)</code>)
 * @export
 * @param {*} child
 * @param {*=} position
 * @return {*}
 */
com.greensock.core.SimpleTimeline.prototype.insert = function(child, position) {
  position = typeof position !== 'undefined' ? position : 0;
  return this.add(child, position || 0);
};


/**
 * Adds a TweenLite, TweenMax, TimelineLite, or TimelineMax instance to the timeline at a specific time. 
 * In classes like TimelineLite and TimelineMax that override this method, it allows things like callbacks,
 * labels, and arrays of tweens/timelines/callbacks/labels to be inserted too. They also allow the position to
 * be defined in terms of either a numeric time or a label (String).
 * 
 * @asparam child TweenLite, TweenMax, TimelineLite, or TimelineMax instance to insert
 * @asparam position The position at which the tween/timeline should be inserted which can be expressed as a number (for an absolute time as seconds or frames for frames-based timelines) or a string, using "+=" or "-=" prefix to indicate a relative value (relative to the END of the timeline). For example, <code>myTimeline.insert(myTween, 3)</code> would insert myTween 3 seconds into the timeline.
 * @asparam align Determines how the tweens/timelines/callbacks/labels will be aligned in relation to each other before getting inserted. Options are: <code>"sequence"</code> (aligns them one-after-the-other in a sequence), <code>"start"</code> (aligns the start times of all of the objects (ignoring delays)), and <code>"normal"</code> (aligns the start times of all the tweens (honoring delays)). The default is <code>"normal"</code>.
 * @asparam stagger Staggers the inserted objects by a set amount of time (in seconds) (or in frames for frames-based timelines). For example, if the stagger value is 0.5 and the <code>"align"</code> parameter is set to <code>"start"</code>, the second one will start 0.5 seconds after the first one starts, then 0.5 seconds later the third one will start, etc. If the align property is <code>"sequence"</code>, there would be 0.5 seconds added between each tween. Default is 0.
 * @asreturn this timeline instance (useful for chaining like <code>myTimeline.add(...).add(...)</code>)
 * @export
 * @param {*} child
 * @param {*=} position
 * @param {string=} align
 * @param {number=} stagger
 * @return {*}
 */
com.greensock.core.SimpleTimeline.prototype.add = function(child, position, align, stagger) {
  position = typeof position !== 'undefined' ? position : "+=0";
  align = typeof align !== 'undefined' ? align : "normal";
  stagger = typeof stagger !== 'undefined' ? stagger : 0;
  child._startTime = Number(position || 0) + child._delay;
  if (child._paused)
    if (this != child._timeline) {
      child._pauseTime = child._startTime + ((this.rawTime() - child._startTime) / child._timeScale);
    }
  if (child.timeline) {
    child.timeline._remove(child, true);
  }
  child.timeline = child._timeline = this;
  if (child._gc) {
    child._enabled(true, true);
  }
  var /** @type {com.greensock.core.Animation} */ prevTween = this._last;
  if (this._sortChildren) {
    var /** @type {number} */ st = Number(child._startTime);
    while (prevTween && prevTween._startTime > st) {
      prevTween = prevTween._prev;
    }
  }
  if (prevTween) {
    child._next = prevTween._next;
    prevTween._next = org.apache.royale.utils.Language.as(child, com.greensock.core.Animation, true);
  } else {
    child._next = this._first;
    this._first = org.apache.royale.utils.Language.as(child, com.greensock.core.Animation, true);
  }
  if (child._next) {
    child._next._prev = child;
  } else {
    this._last = org.apache.royale.utils.Language.as(child, com.greensock.core.Animation, true);
  }
  child._prev = prevTween;
  if (this._timeline) {
    this._uncache(true);
  }
  return this;
};


/** @asprivate *
 * @export
 * @param {com.greensock.core.Animation} tween
 * @param {boolean=} skipDisable
 * @return {*}
 */
com.greensock.core.SimpleTimeline.prototype._remove = function(tween, skipDisable) {
  skipDisable = typeof skipDisable !== 'undefined' ? skipDisable : false;
  if (tween.timeline == this) {
    if (!skipDisable) {
      tween._enabled(false, true);
    }
    if (tween._prev) {
      tween._prev._next = tween._next;
    } else if (this._first === tween) {
      this._first = tween._next;
    }
    if (tween._next) {
      tween._next._prev = tween._prev;
    } else if (this._last === tween) {
      this._last = tween._prev;
    }
    tween._next = tween._prev = tween.timeline = null;
    if (this._timeline) {
      this._uncache(true);
    }
  }
  return this;
};


/** @inheretDoc *
 * @export
 * @override
 */
com.greensock.core.SimpleTimeline.prototype.render = function(time, suppressEvents, force) {
  suppressEvents = typeof suppressEvents !== 'undefined' ? suppressEvents : false;
  force = typeof force !== 'undefined' ? force : false;
  var /** @type {com.greensock.core.Animation} */ tween = this._first, /** @type {com.greensock.core.Animation} */ next;
  this._totalTime = this._time = this._rawPrevTime = time;
  while (tween) {
    next = tween._next;
    if (tween._active || (time >= tween._startTime && !tween._paused)) {
      if (!tween._reversed) {
        tween.render((time - tween._startTime) * tween._timeScale, suppressEvents, force);
      } else {
        tween.render(((!tween._dirty) ? tween._totalDuration : tween.totalDuration()) - ((time - tween._startTime) * tween._timeScale), suppressEvents, force);
      }
    }
    tween = next;
  }
};


/**
 * @asprivate
 * Reports the totalTime of the timeline without capping the number at the <code>totalDuration</code> (max) and zero (minimum) 
 * which can be useful when unpausing tweens/timelines. Imagine a case where a paused tween is in a timeline that has already 
 * reached the end, but then the tween gets unpaused - it needs a way to place itself accurately in time AFTER what was 
 * previously the timeline's end time. In a SimpleTimeline, <code>rawTime</code> is always the same as <code>_totalTime</code>, 
 * but in TimelineLite and TimelineMax, it can be different.
 * 
 * @asreturn The <code>totalTime</code> of the timeline without capping the number at the <code>totalDuration</code> (max) and zero (minimum)
 * @export
 * @return {number}
 */
com.greensock.core.SimpleTimeline.prototype.rawTime = function() {
  return this._totalTime;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
com.greensock.core.SimpleTimeline.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'SimpleTimeline', qName: 'com.greensock.core.SimpleTimeline', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
com.greensock.core.SimpleTimeline.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'autoRemoveChildren': { type: 'Boolean'},
        'smoothChildTiming': { type: 'Boolean'},
        '_sortChildren': { type: 'Boolean'},
        '_first': { type: 'com.greensock.core.Animation'},
        '_last': { type: 'com.greensock.core.Animation'}
      };
    },
    accessors: function () {return {};},
    methods: function () {
      return {
        'SimpleTimeline': { type: '', declaredBy: 'com.greensock.core.SimpleTimeline', parameters: function () { return [  { index: 1, type: 'Object', optional: true } ]; }},
        'insert': { type: '*', declaredBy: 'com.greensock.core.SimpleTimeline', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: '*', optional: true } ]; }},
        'add': { type: '*', declaredBy: 'com.greensock.core.SimpleTimeline', parameters: function () { return [  { index: 1, type: '*', optional: false },{ index: 2, type: '*', optional: true },{ index: 3, type: 'String', optional: true },{ index: 4, type: 'Number', optional: true } ]; }},
        '_remove': { type: '*', declaredBy: 'com.greensock.core.SimpleTimeline', parameters: function () { return [  { index: 1, type: 'com.greensock.core.Animation', optional: false },{ index: 2, type: 'Boolean', optional: true } ]; }},
        'render': { type: 'void', declaredBy: 'com.greensock.core.SimpleTimeline', parameters: function () { return [  { index: 1, type: 'Number', optional: false },{ index: 2, type: 'Boolean', optional: true },{ index: 3, type: 'Boolean', optional: true } ]; }},
        'rawTime': { type: 'Number', declaredBy: 'com.greensock.core.SimpleTimeline'}
      };
    }
  };
};
