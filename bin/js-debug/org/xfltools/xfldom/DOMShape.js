/**
 * Generated by Apache Royale Compiler from org\xfltools\xfldom\DOMShape.as
 * org.xfltools.xfldom.DOMShape
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('org.xfltools.xfldom.DOMShape');
/* Royale Dependency List: XML,flash.display.DisplayObject,flash.display.GraphicsEndFill,flash.display.GraphicsPath,flash.display.GraphicsPathCommand,flash.display.IGraphicsData,flash.display.Shape,org.xfltools.utils.XMLAssistant,org.xfltools.xfldom.Edge,org.xfltools.xfldom.EdgeDescriptor,org.xfltools.xfldom.FillStyle,org.xfltools.xfldom.StrokeStyle,org.apache.royale.utils.Language*/

goog.require('org.xfltools.xfldom.IDOMComponent');
goog.require('org.xfltools.xfldom.IDOMFrameElement');
goog.require('org.xfltools.xfldom.IGraphicsDrawable');



/**
 * @constructor
 * @implements {org.xfltools.xfldom.IDOMComponent}
 * @implements {org.xfltools.xfldom.IGraphicsDrawable}
 * @implements {org.xfltools.xfldom.IDOMFrameElement}
 */
org.xfltools.xfldom.DOMShape = function() {
};


/**
 * Prevent renaming of class. Needed for reflection.
 */
goog.exportSymbol('org.xfltools.xfldom.DOMShape', org.xfltools.xfldom.DOMShape);


/**
 * @private
 * @type {Array}
 */
org.xfltools.xfldom.DOMShape.prototype._fills;


/**
 * @private
 * @type {Array}
 */
org.xfltools.xfldom.DOMShape.prototype._strokes;


/**
 * @private
 * @type {Array}
 */
org.xfltools.xfldom.DOMShape.prototype._edgeDescriptors;


/**
 * @export
 * @param {XML} xml
 */
org.xfltools.xfldom.DOMShape.prototype.fromXML = function(xml) {
  this._fills = org.apache.royale.utils.Language.Vector();
  this._strokes = org.apache.royale.utils.Language.Vector();
  var /** @type {org.xfltools.xfldom.StrokeStyle} */ strokeStyle;
  var /** @type {org.xfltools.xfldom.FillStyle} */ fillStyle;
  var foreachiter0_target = org.xfltools.utils.XMLAssistant.getChildList(xml, ["strokes", "StrokeStyle"]);
  for (var foreachiter0 in foreachiter0_target) 
  {
  var strokeStyleXML = foreachiter0_target[foreachiter0];
  {
    strokeStyle = new org.xfltools.xfldom.StrokeStyle();
    strokeStyle.fromXML(strokeStyleXML);
    this._strokes.push(strokeStyle);
  }}
  
  var foreachiter1_target = org.xfltools.utils.XMLAssistant.getChildList(xml, ["fills", "FillStyle"]);
  for (var foreachiter1 in foreachiter1_target) 
  {
  var fillStyleXML = foreachiter1_target[foreachiter1];
  {
    fillStyle = new org.xfltools.xfldom.FillStyle();
    fillStyle.fromXML(fillStyleXML);
    this._fills.push(fillStyle);
  }}
  
  var /** @type {Array} */ edges = org.apache.royale.utils.Language.Vector();
  var /** @type {number} */ lastStrokeStyle = -1;
  var /** @type {number} */ lastFillStyleLeft = -1;
  var /** @type {number} */ lastFillStyleRight = -1;
  var foreachiter2_target = org.xfltools.utils.XMLAssistant.getChildList(xml, ["edges", "Edge"]);
  for (var foreachiter2 in foreachiter2_target) 
  {
  var edgeXML = foreachiter2_target[foreachiter2];
  {
    var /** @type {number} */ fillStyleLeft = parseInt(edgeXML.attribute('fillStyle0'), undefined);
    var /** @type {number} */ fillStyleRight = parseInt(edgeXML.attribute('fillStyle1'), undefined);
    var /** @type {number} */ strokeStyleIndex = parseInt(edgeXML.attribute('strokeStyle'), undefined);
    if (!strokeStyleIndex && !lastFillStyleLeft && !fillStyleRight) {
      strokeStyleIndex = lastStrokeStyle;
      fillStyleLeft = lastFillStyleLeft;
      fillStyleRight = lastFillStyleRight;
    }
    var /** @type {org.xfltools.xfldom.Edge} */ edge = new org.xfltools.xfldom.Edge(strokeStyleIndex, 0);
    edge.fromXML(edgeXML);
    edges.push(edge);
    edge = new org.xfltools.xfldom.Edge(0, fillStyleRight);
    edge.fromXML(edgeXML);
    edges.push(edge);
    if (fillStyleLeft) {
      edge = new org.xfltools.xfldom.Edge(0, fillStyleLeft);
      edge.fromXML(edgeXML);
      edge.reverse();
      edges.push(edge);
    }
    lastStrokeStyle = strokeStyleIndex;
    lastFillStyleLeft = fillStyleLeft;
    lastFillStyleRight = fillStyleRight;
  }}
  
  var /** @type {Array} */ edgeDescriptors = org.apache.royale.utils.Language.Vector();
  var foreachiter3_target = edges;
  for (var foreachiter3 in foreachiter3_target) 
  {
  edge = foreachiter3_target[foreachiter3];
  {
    edgeDescriptors = edgeDescriptors.concat(edge.edgeDescriptors);
  }}
  
  this.sortEdgeDescriptors(edgeDescriptors);
};


/**
 * @private
 * @param {Array} edgeDescriptors
 */
org.xfltools.xfldom.DOMShape.prototype.sortEdgeDescriptors = function(edgeDescriptors) {
  this._edgeDescriptors = org.apache.royale.utils.Language.Vector();
  while (edgeDescriptors.length > 0) {
    var /** @type {Array} */ currentSet = [edgeDescriptors.shift()];
    this.findFriendEdges(currentSet, edgeDescriptors);
    this._edgeDescriptors.push(currentSet);
  }
  this._edgeDescriptors.sort(org.apache.royale.utils.Language.closure(this.sortFillsFirst, this, 'sortFillsFirst'));
};


/**
 * @private
 * @param {Array} edgeDescriptorA
 * @param {Array} edgeDescriptorB
 * @return {number}
 */
org.xfltools.xfldom.DOMShape.prototype.sortFillsFirst = function(edgeDescriptorA, edgeDescriptorB) {
  if (edgeDescriptorA[0].fillStyle && !edgeDescriptorB[0].fillStyle) {
    return -1;
  } else if (!edgeDescriptorA[0].fillStyle && edgeDescriptorB[0].fillStyle) {
    return 1;
  }
  return 0;
};


/**
 * @private
 * @param {Array} theseEdges
 * @param {Array} allEdges
 */
org.xfltools.xfldom.DOMShape.prototype.findFriendEdges = function(theseEdges, allEdges) {
  var /** @type {boolean} */ friendFound = false;
  for (var /** @type {number} */ i = 0; i < allEdges.length; i++) {
    if (allEdges[i].strokeStyle == theseEdges[0].strokeStyle && allEdges[i].fillStyle == theseEdges[0].fillStyle) {
      if (allEdges[i].start.equals(theseEdges[theseEdges.length - 1].end)) {
        theseEdges.push(allEdges.splice(i, 1)[0]);
        friendFound = true;
        break;
      } else if (allEdges[i].end.equals(theseEdges[0].start)) {
        theseEdges.unshift(allEdges.splice(i, 1)[0]);
        friendFound = true;
        break;
      }
    }
  }
  if (friendFound) {
    this.findFriendEdges(theseEdges, allEdges);
  }
};


/**
 * @private
 * @param {number} fillIndex
 * @return {org.xfltools.xfldom.FillStyle}
 */
org.xfltools.xfldom.DOMShape.prototype.fillStyleFromIndex = function(fillIndex) {
  var foreachiter4_target = this._fills;
  for (var foreachiter4 in foreachiter4_target) 
  {
  var fillStyle = foreachiter4_target[foreachiter4];
  {
    if (fillStyle.index == fillIndex) {
      return fillStyle;
    }
  }}
  
  return null;
};


/**
 * @private
 * @param {number} strokeIndex
 * @return {org.xfltools.xfldom.StrokeStyle}
 */
org.xfltools.xfldom.DOMShape.prototype.strokeStyleFromIndex = function(strokeIndex) {
  var foreachiter5_target = this._strokes;
  for (var foreachiter5 in foreachiter5_target) 
  {
  var strokeStyle = foreachiter5_target[foreachiter5];
  {
    if (strokeStyle.index == strokeIndex) {
      return strokeStyle;
    }
  }}
  
  return null;
};


/**
 * @export
 * @return {Array}
 */
org.xfltools.xfldom.DOMShape.prototype.toGraphicsData = function() {
  var /** @type {Array} */ graphicsData = org.apache.royale.utils.Language.Vector();
  var /** @type {Array} */ pathCoordinates = org.apache.royale.utils.Language.Vector();
  var /** @type {Array} */ pathCommands = org.apache.royale.utils.Language.Vector();
  var foreachiter6_target = this._edgeDescriptors;
  for (var foreachiter6 in foreachiter6_target) 
  {
  var edgeSet = foreachiter6_target[foreachiter6];
  {
    if (edgeSet[0].strokeStyle > 0) {
      var /** @type {org.xfltools.xfldom.StrokeStyle} */ strokeStyle = this.strokeStyleFromIndex(edgeSet[0].strokeStyle);
      graphicsData = graphicsData.concat(strokeStyle.toGraphicsData());
    } else if (edgeSet[0].fillStyle > 0) {
      var /** @type {org.xfltools.xfldom.FillStyle} */ fillStyle = this.fillStyleFromIndex(edgeSet[0].fillStyle);
      graphicsData = graphicsData.concat(fillStyle.toGraphicsData());
    }
    pathCoordinates = org.apache.royale.utils.Language.Vector();
    pathCommands = org.apache.royale.utils.Language.Vector();
    pathCommands[0] = flash.display.GraphicsPathCommand.MOVE_TO;
    pathCoordinates.push(edgeSet[0].start.x, edgeSet[0].start.y);
    var foreachiter7_target = edgeSet;
    for (var foreachiter7 in foreachiter7_target) 
    {
    var edgeDescriptor = foreachiter7_target[foreachiter7];
    {
      if (edgeDescriptor.control) {
        pathCommands.push(flash.display.GraphicsPathCommand.CURVE_TO);
        pathCoordinates.push(edgeDescriptor.control.x, edgeDescriptor.control.y, edgeDescriptor.end.x, edgeDescriptor.end.y);
      } else {
        pathCommands.push(flash.display.GraphicsPathCommand.LINE_TO);
        pathCoordinates.push(edgeDescriptor.end.x, edgeDescriptor.end.y);
      }
    }}
    
    var /** @type {flash.display.GraphicsPath} */ graphicsPath = new flash.display.GraphicsPath(pathCommands, pathCoordinates);
    graphicsData.push(graphicsPath);
    if (edgeSet[0].fillStyle > 0) {
      graphicsData.push(new flash.display.GraphicsEndFill());
    }
  }}
  
  return graphicsData;
};


/**
 * @export
 * @return {flash.display.DisplayObject}
 */
org.xfltools.xfldom.DOMShape.prototype.toDisplayObject = function() {
  var /** @type {Array} */ graphicsData = this.toGraphicsData();
  var /** @type {flash.display.Shape} */ shape = new flash.display.Shape();
  shape.graphics.drawGraphicsData(graphicsData);
  return shape;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
org.xfltools.xfldom.DOMShape.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'DOMShape', qName: 'org.xfltools.xfldom.DOMShape', kind: 'class' }], interfaces: [org.xfltools.xfldom.IDOMComponent, org.xfltools.xfldom.IGraphicsDrawable, org.xfltools.xfldom.IDOMFrameElement] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
org.xfltools.xfldom.DOMShape.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {return {};},
    accessors: function () {return {};},
    methods: function () {
      return {
        'DOMShape': { type: '', declaredBy: 'org.xfltools.xfldom.DOMShape'},
        'fromXML': { type: 'void', declaredBy: 'org.xfltools.xfldom.DOMShape', parameters: function () { return [  { index: 1, type: 'XML', optional: false } ]; }},
        'toGraphicsData': { type: 'Vector.<flash.display.IGraphicsData>', declaredBy: 'org.xfltools.xfldom.DOMShape'},
        'toDisplayObject': { type: 'flash.display.DisplayObject', declaredBy: 'org.xfltools.xfldom.DOMShape'}
      };
    }
  };
};
